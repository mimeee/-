# 微型计算机系统

## 目录

1. [微型计算机是什么](note.md#微型计算机是什么)
2. [微型计算机的组成](note.md#微型计算机的组成)
3. [微型计算机的工作过程](note.md#微型计算机的工作过程)
4. [冯诺依曼计算机](node.md#冯诺依曼计算机)

- ## 微型计算机是什么

  在平时我们使用的个人计算机等就是微型计算机。

- ## 微型计算机的组成

  微型计算机系统由 **硬件系统** 和 **软件系统** 两个部分组成。计算机和计算机系统不是一样的概念。计算机只是包含计算机硬件。

  - #### 硬件系统

    硬件系统包括 **<font color="yellow">主机系统</font>** 和 **<font color="yellow">外部设备</font>**。  
    
    1. **外部设备** 是指能够和计算机进行信息交换，同时又不能直接和计算机进行信息交换，需要通过第三方进行(简单的说外部设备不能直接和cpu进行交换，必须通过输入输出接口，例如鼠标，打印机等等)。 

    2. **主机系统** 包括：

       1. **<font color="#a890f5">cpu</font>**(微处理器): 运算器，控制器，寄存器
   2. **<font color="#a890f5">存储器</font>**: 内存，外存(联机外存(硬盘，如SATA)，脱机外存(移动硬盘))
    
       关于内存储器

       - 表现形式: 内存储器的物理表现形式是有一个一个的黑块块，这些黑块块就是内存芯片。
        ![storage](/Users/mimee/Documents/my-git/work/computer_fundament/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/image/20190524_1.png)
  
    内存储器的逻辑表现形式是：他是按照单元组织的，每个单元对应于一个内存地址。每个单元的容量都是一样的，即为1字节(1byte = 8bit)。可以把内存条想象一幢大厦，里面的房间想象成单元，房间的门牌号(唯一的)想象成单元地址(唯一的)，房间可容纳的人想象成单元容量。
  
   - 内存操作：读和写；读操作的过程是一个复制的过程，cpu读取内存中的数据是从内存中把数据复制过来，不会对内存中的数据进行破坏。写操作则是是一个破坏性的操作。
       - 分类
         - 随机存取存储器(RAM)：随电而生，随电而亡
     - 只读存储器(ROM)：u盘，不需要电，写操作由条件
  
   3. **<font color="#a890f5">输入输出接口</font>**(I/O system): CPU和外部设备通信的桥梁  cpu <------> I/O接口 <--------> 外设
  
   - 存在的理由：由于cpu运行速度很快，但是外设的运行速度很慢。如果让cpu取迁就外设，那电脑就没办法用了，于是就有了输入输出接口来平滑这个速度差。平滑的方式就是像暂存区一样，首先接口是专用的，cpu咵的一声就把数据丢到那里了，外设在自己慢慢的从接口中挪数据。而如果是取数据则是，外设慢慢的把数据放在接口处，放完告诉cpu，cpu又咵一声取走了。这样不会耽误cpu干其他事。
       - 主要功能：数据换成寄存；信号电平或类型的转换；实现主机和外设间的运行匹配。

       4. **<font color="#a890f5">总线</font>**
          总线上跑的都是高低电平(也就是0,1)，由于他就像是马路，信息就像是车子，马路就这么宽，而车(信息)有很多，所以总线总是存在着争用。所以总线要有裁判的功能。


- ## 微型计算机的工作过程
    无论程序是由什么语言编写，到了计算机去实现的时候，都是转变成了一条一条0,1的指令序列。
    - 计算机的工作过程(外存，内存，cpu)
        - 指令的编写: 在今天，我们所编写的程序要想让电脑(cpu)执行，必须存放在内存中。因为只有内存才可以和cpu进行交换。而编写完的程序一般是放在硬盘中，交给内存的程序都是经过0,1编码转化成一条一条语句，在转交给内存。
        - 计算机执行指令的过程
            - <font color="red">获取指令(核心)</font>
            - <font color="red">指令译码(核心)</font>
            - 获取数据
            - <font color="red">执行指令(核心)</font>
            - 存放结果
        - 指令执行顺序: 顺序，并行;
            - 顺序执行：指令完成一个在进行下一个
            - 并行执行：总线在运送完指令后，不等待指令完成就去运送下一个。
            - 加速比：两种方式的执行时间的比值
            - 为什么会有两种并行的指令执行顺序？原因在于cpu在完成人们需求的过程中分为了上述5步，而获取指令是通过总线来把数据从外存拉到内存进行中，然后再进行指令译码以及执行指令的过程。在这个过程中，如果是顺序的执行顺序，也就是说完成一个指令再执行下一个指令，会导致总线在指令译码以及执行指令的过程中空闲。所以为了提高总线的利用率，就有了并行的执行顺序。
    
- ## 冯诺依曼计算机

    #### 原理：存储程序原理

    #### 计算机的一般工作过程

    参与工作的部件：寄存器( pc， AR， DR...)，存储器，控制器，总线，运算器

    相关部件的解释：

    - pc: (也相当于一个寄存器)里面存储着要运算的程序的第一条指令的地址，他的作用就是指针，指向程序存储的地址。

    - AR: 用来暂存地址的暂存器

    - DR：用来赞成数据的暂存器

    过程：

    pc将指令地址传送给AR，AR通过地址去访问该内存单元的内容，控制器下指令取出该内容，并进行指令译码。根据指令进行动作，如有结果输出则送至输入输出接口。

    

    #### 不足

    1. pc将指令传给AR，证明寄存器之间交互很多，所以对总线要求很高
    2. 由程序控制执行顺序，表示不适合高并发的复杂程序。
    3. 由运算器为核心，运算效率不高



- ## 数值及其转化

  - 二进制，八进制，十六进制转化为十进制

  由每个位乘以该进制的位的序号减一次幂，相加。比如：

  1010B = 0 * 2的<font color = 'red'>0次幂</font> + 1 * 2的的<font color = 'red'>1次幂</font>+ 0 * 2的<font color = 'red'>2次幂</font> + 1 * 2的<font color = 'red'>3次幂</font> = 10

  - 十进制转化为二进制

  用十进制除2取余。小数的话则是乘2取整。

  100.2; 分成 100 以及 0.2；

  100转成二进制为： 

  100 /2 = 50 ……0   

  50 /  2 = 25 ……0

  25 /  2  = 12 ……1

  12  / 2   = 3  ……0

  3   /  2   =  1 ……1

  1  /  2    =  0 ……1

  0.2转成二进制为： 

  0.2 * 2 = 0.4   0

  0.4 * 2 = 0.8   0

  0.8 * 2 = 1.6   1

  0.6 / 2 = 1.2   1

  0.2 * 2 = 0.4   0

  ……

  所以最后结果为110100.00110…..

  - 二进制转化为八进制，十六进制

  二进制中四位表示十六进制一位

  二进制中三位表示八进制一位

- ## 编码

  - 编码就是把一种数据合格转换成另一种数据格式。比如把十进制转成二进制。编码的原因是因为计算机智能识别高低电平也就是0和1，所以为了让计算机认识指令，任何数据格式都要处理成0和1的格式。但0和1对于人却不太友好，所以当我们编程的时候，需要把我熟悉的数据格式转换成计算机熟悉的数据格式。

  - #### 主要的编码格式：

    - 二进制编码：用二进制存储的数据格式

    - BCD编码( Binary Coded Decimal )：使用0和1的数据，但是保留逢10进1的规则。其主要也是给人看的。计算机不可以识别该编码。比如 *0001 1001*表示19(十进制)

      - 要达到这个目标就必须要使用 **4位二进制** 来表示1个BCD 编码。因为 3位二进制码最多只能表示到8；而4位二进制码可以表示到16；所以10以上的二进制码是无效的，即 1010 到 1111 都是无效的。
      - 由于用 **4位二进制码** 表示一个数，根据每位的权值(2的幂)也称该编码位 **8421BCD编码**；
      - **转化**：将BCD编码转化成二进制，需要先转化成十进制。
      - **存储**：
        - 压缩BCD码：因为使用4位二进制来表示一个十进制的数，而计算机一个字节是8位，所以一个字节可以存放两个BCD码。当一个内存单元存放两个BCD码，就称作压缩BCD码
        - 扩展BCD码：一个内存单元存放一个BCD码，高位多出的4位使用0补齐，就称为扩展BCD码。

      

    - ASCII编码

      - 格式：由字母，数字，标点，控制器组成，由8位二进制来表示的编码。一般只使用7位，高位默认为0.
      - 校验：奇偶校验：为了防止在传送中出现错误，在8位二进制的最高位使用 **0**和 **1**来表示有  **偶数**或者 **奇数**个1.即最高位使用 0表示由偶数个1，使用1表示由奇数个1.



 - ## 数的表示和运算

    - #### 按数的表示方法分

       - 定点数
         	- 在内存在存储的时候会带上小数点。
          - 缺点：
            1. 现在的计算机都是64位的，按该方法，内存中存储的数的大小限制较大。如果两个差异特别大的数比如10的30次方和10的-30次方，是没有办法一块进行运算的。
            2. 计算的过程中首先要寻找小数点，对齐进行计算，过程比较复杂。
       - 浮点数
         	- 使用类似于科学计数法的方法，以0.xxx乘以10的n次幂的方法。其中小数点后一位 **必须不为0，小数点前面为0**，其中 **0.xxx表示尾数**，而 **10表示阶基**，最后 **n表示阶级**。该数的表现方式大大提高计算机一个字节可以存储的数的大小。

    - #### 按数的性质分(统称机器数)

       - 无符号数
         	- 所有位上的数都是有意义的数字。比如编码啊等，都是使用无符号数。
          - 运算：
            1. 加法
            2. 减法
            3. 乘法
            4. 除法
          
       - 有符号数
         	
         	- 最高位是符号位。表示数字的正负。比如1或者-1就是使用有符号数。
         	
          - 有符号数的表示
       
             - 对于一个正数来说，其原码等于反码等于补码，即 X > 0; X原码 = X反码 = X补码
       
             - 对于一个负数来说，其反码等于原码除符号位取反，补码等于其反码加1；
       
             即  X < 0； X反码 = X原码取反(符号位置不取)
       
             ​				   X补码 = X反码 + 1；
       
             比如: X = 1 111 0000; 其反码是 1 000 1111； 其补码是 1 001 0000；
       
             - 原码
               	    - 原码就是给的数字本身，符号位，正数用0表示，负数用1表示。
       
             - 反码
               	    - 原码(负数)的符号位的数字不变，其余位数取反。 **原码** 和 **反码** 的缺点是基准不唯一，也就是0的表示由两种。同时减肥运算相较于加法运算更加麻烦。
       
             - 补码
               	    - 原码(负数)的反码加1。比如 +0 的原码是 0000 0000， -0的原码是 1000 0000，而它们的补码都是 0000 0000。 这样不但基数统一了，同时可以把减法运算变为加法运算。
       
          - 在计算机中的一个特殊的数字  **1 000 0000**
       
            	    - 他如果是无符号数，则表示为 2 的 7 次方， 即为 128；
             - 如果是有符号数字
               	    - 其原码表示为： -0
               	    - 其反码表示为:   -127
               	    - 其补码表示为:   -128 (这个是规定，因为补码把 +0 和 -0 统一了，所以多了一个位置， 人为的定义其为 -128 )
       
    - #### 计算机的局限性
    
       计算机可以表示的数的范围称为 **表数**；受硬件的影响的关系，不管是以前的8位计算机还是现在的64位计算机，对于数字的表示都是有范围的。如果超出了这个表示的范围，则称为 **溢出**。
    
       - 对于 **溢出** 的判断方法
         - 无符号数：最高位是否进位
           - 比如: 1111 1111 + 0000 0001 = 1 0000 0000 最高位进位，溢出
         - 有符号数：最高位和次高位是否同时有进位，或者同时没有进位。(只指加减)
           - 比如：0111 1111 + 0000 0001 = 1000 0000  次高位向最高位 进1，而最高位没有进位， 溢出。
       - 符号二进制和十进制的转化
         - 有符号数的二进制转化，需要求出真值都再进行转换。如果改数是正值，则原码反码补码皆是真值；如果是负数，需要将反码以及补码转化成原码，在进行转化。










