# 微型计算机系统

## 目录

1. [微型计算机是什么](note.md#微型计算机是什么)
2. [微型计算机的组成](note.md#微型计算机的组成)
3. [微型计算机的工作过程](note.md#微型计算机的工作过程)
4. [冯诺依曼计算机](node.md#冯诺依曼计算机)

- ## 微型计算机是什么

  在平时我们使用的个人计算机等就是微型计算机。

- ## 微型计算机的组成

  微型计算机系统由 **硬件系统** 和 **软件系统** 两个部分组成。计算机和计算机系统不是一样的概念。计算机只是包含计算机硬件。

  - #### 硬件系统

    硬件系统包括 **<font color="yellow">主机系统</font>** 和 **<font color="yellow">外部设备</font>**。  
    
    1. **外部设备** 是指能够和计算机进行信息交换，同时又不能直接和计算机进行信息交换，需要通过第三方进行(简单的说外部设备不能直接和cpu进行交换，必须通过输入输出接口，例如鼠标，打印机等等)。 

    2. **主机系统** 包括：

       1. **<font color="#a890f5">cpu</font>**(微处理器): 运算器，控制器，寄存器
       2. **<font color="#a890f5">存储器</font>**: 内存，外存(联机外存(硬盘，如SATA)，脱机外存(移动硬盘))
  
  关于内存储器

  - 表现形式: 内存储器的物理表现形式是有一个一个的黑块块，这些黑块块就是内存芯片。
   ![storage](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190524_1.png)
  
    内存储器的逻辑表现形式是：他是按照单元组织的，每个单元对应于一个内存地址。每个单元的容量都是一样的，即为1字节(1byte = 8bit)。可以把内存条想象一幢大厦，里面的房间想象成单元，房间的门牌号(唯一的)想象成单元地址(唯一的)，房间可容纳的人想象成单元容量。
  
   - 内存操作：读和写；读操作的过程是一个复制的过程，cpu读取内存中的数据是从内存中把数据复制过来，不会对内存中的数据进行破坏。写操作则是是一个破坏性的操作。
       - 分类
         - 随机存取存储器(RAM)：随电而生，随电而亡
     - 只读存储器(ROM)：u盘，不需要电，写操作由条件
       3. **<font color="#a890f5">输入输出接口</font>**(I/O system): CPU和外部设备通信的桥梁  cpu <------> I/O接口 <--------> 外设
  
   - 存在的理由：由于cpu运行速度很快，但是外设的运行速度很慢。如果让cpu取迁就外设，那电脑就没办法用了，于是就有了输入输出接口来平滑这个速度差。平滑的方式就是像暂存区一样，首先接口是专用的，cpu咵的一声就把数据丢到那里了，外设在自己慢慢的从接口中挪数据。而如果是取数据则是，外设慢慢的把数据放在接口处，放完告诉cpu，cpu又咵一声取走了。这样不会耽误cpu干其他事。
     
       - 主要功能：数据换成寄存；信号电平或类型的转换；实现主机和外设间的运行匹配。
    4. **<font color="#a890f5">总线</font>**
          总线上跑的都是高低电平(也就是0,1)，由于他就像是马路，信息就像是车子，马路就这么宽，而车(信息)有很多，所以总线总是存在着争用。所以总线要有裁判的功能。
  


- ## 微型计算机的工作过程
    无论程序是由什么语言编写，到了计算机去实现的时候，都是转变成了一条一条0,1的指令序列。
    - 计算机的工作过程(外存，内存，cpu)
        - 指令的编写: 在今天，我们所编写的程序要想让电脑(cpu)执行，必须存放在内存中。因为只有内存才可以和cpu进行交换。而编写完的程序一般是放在硬盘中，交给内存的程序都是经过0,1编码转化成一条一条语句，在转交给内存。
        - 计算机执行指令的过程
            - <font color="red">获取指令(核心)</font>
            - <font color="red">指令译码(核心)</font>
            - 获取数据
            - <font color="red">执行指令(核心)</font>
            - 存放结果
        - 指令执行顺序: 顺序，并行;
            - 顺序执行：指令完成一个在进行下一个
            - 并行执行：总线在运送完指令后，不等待指令完成就去运送下一个。
            - 加速比：两种方式的执行时间的比值
            - 为什么会有两种并行的指令执行顺序？原因在于cpu在完成人们需求的过程中分为了上述5步，而获取指令是通过总线来把数据从外存拉到内存进行中，然后再进行指令译码以及执行指令的过程。在这个过程中，如果是顺序的执行顺序，也就是说完成一个指令再执行下一个指令，会导致总线在指令译码以及执行指令的过程中空闲。所以为了提高总线的利用率，就有了并行的执行顺序。
    
- ## 冯诺依曼计算机

    #### 原理：存储程序原理

    #### 计算机的一般工作过程

    参与工作的部件：寄存器( pc， AR， DR...)，存储器，控制器，总线，运算器

    相关部件的解释：

    - pc: (也相当于一个寄存器)里面存储着要运算的程序的第一条指令的地址，他的作用就是指针，指向程序存储的地址。

    - AR: 用来暂存地址的暂存器

    - DR：用来赞成数据的暂存器

    过程：

    pc将指令地址传送给AR，AR通过地址去访问该内存单元的内容，控制器下指令取出该内容，并进行指令译码。根据指令进行动作，如有结果输出则送至输入输出接口。

    

    #### 不足

    1. pc将指令传给AR，证明寄存器之间交互很多，所以对总线要求很高
    2. 由程序控制执行顺序，表示不适合高并发的复杂程序。
    3. 由运算器为核心，运算效率不高



- ## 数值及其转化

  - 二进制，八进制，十六进制转化为十进制

  由每个位乘以该进制的位的序号减一次幂，相加。比如：

  1010B = 0 * 2的<font color = 'red'>0次幂</font> + 1 * 2的的<font color = 'red'>1次幂</font>+ 0 * 2的<font color = 'red'>2次幂</font> + 1 * 2的<font color = 'red'>3次幂</font> = 10

  - 十进制转化为二进制

  用十进制除2取余。小数的话则是乘2取整。

  100.2; 分成 100 以及 0.2；

  100转成二进制为： 

  100 /2 = 50 ……0   

  50 /  2 = 25 ……0

  25 /  2  = 12 ……1

  12  / 2   = 3  ……0

  3   /  2   =  1 ……1

  1  /  2    =  0 ……1

  0.2转成二进制为： 

  0.2 * 2 = 0.4   0

  0.4 * 2 = 0.8   0

  0.8 * 2 = 1.6   1

  0.6 / 2 = 1.2   1

  0.2 * 2 = 0.4   0

  ……

  所以最后结果为110100.00110…..

  - 二进制转化为八进制，十六进制

  二进制中四位表示十六进制一位

  二进制中三位表示八进制一位

- ## 编码

  - 编码就是把一种数据合格转换成另一种数据格式。比如把十进制转成二进制。编码的原因是因为计算机智能识别高低电平也就是0和1，所以为了让计算机认识指令，任何数据格式都要处理成0和1的格式。但0和1对于人却不太友好，所以当我们编程的时候，需要把我熟悉的数据格式转换成计算机熟悉的数据格式。

  - #### 主要的编码格式：

    - 二进制编码：用二进制存储的数据格式

    - BCD编码( Binary Coded Decimal )：使用0和1的数据，但是保留逢10进1的规则。其主要也是给人看的。计算机不可以识别该编码。比如 *0001 1001*表示19(十进制)

      - 要达到这个目标就必须要使用 **4位二进制** 来表示1个BCD 编码。因为 3位二进制码最多只能表示到8；而4位二进制码可以表示到16；所以10以上的二进制码是无效的，即 1010 到 1111 都是无效的。
      - 由于用 **4位二进制码** 表示一个数，根据每位的权值(2的幂)也称该编码位 **8421BCD编码**；
      - **转化**：将BCD编码转化成二进制，需要先转化成十进制。
      - **存储**：
        - 压缩BCD码：因为使用4位二进制来表示一个十进制的数，而计算机一个字节是8位，所以一个字节可以存放两个BCD码。当一个内存单元存放两个BCD码，就称作压缩BCD码
        - 扩展BCD码：一个内存单元存放一个BCD码，高位多出的4位使用0补齐，就称为扩展BCD码。

      

    - ASCII编码

      - 格式：由字母，数字，标点，控制器组成，由8位二进制来表示的编码。一般只使用7位，高位默认为0.
      - 校验：奇偶校验：为了防止在传送中出现错误，在8位二进制的最高位使用 **0**和 **1**来表示有  **偶数**或者 **奇数**个1.即最高位使用 0表示由偶数个1，使用1表示由奇数个1.



 - ## 数的表示和运算

    - #### 按数的表示方法分

       - 定点数
         	- 在内存在存储的时候会带上小数点。
          - 缺点：
            1. 现在的计算机都是64位的，按该方法，内存中存储的数的大小限制较大。如果两个差异特别大的数比如10的30次方和10的-30次方，是没有办法一块进行运算的。
            2. 计算的过程中首先要寻找小数点，对齐进行计算，过程比较复杂。
       - 浮点数
         	- 使用类似于科学计数法的方法，以0.xxx乘以10的n次幂的方法。其中小数点后一位 **必须不为0，小数点前面为0**，其中 **0.xxx表示尾数**，而 **10表示阶基**，最后 **n表示阶级**。该数的表现方式大大提高计算机一个字节可以存储的数的大小。

    - #### 按数的性质分(统称机器数)

       - 无符号数
         	- 所有位上的数都是有意义的数字。比如编码啊等，都是使用无符号数。
          - 运算：
            1. 加法
            2. 减法
            3. 乘法
            4. 除法
          
       - 有符号数
         	
         	- 最高位是符号位。表示数字的正负。比如1或者-1就是使用有符号数。
          
          - 有符号数的表示
       
             - 对于一个正数来说，其原码等于反码等于补码，即 X > 0; X原码 = X反码 = X补码
       
             - 对于一个负数来说，其反码等于原码除符号位取反，补码等于其反码加1；
       
             即  X < 0； X反码 = X原码取反(符号位置不取)
       
             ​				   X补码 = X反码 + 1；
       
             比如: X = 1 111 0000; 其反码是 1 000 1111； 其补码是 1 001 0000；
       
             - 原码
               	    - 原码就是给的数字本身，符号位，正数用0表示，负数用1表示。
       
             - 反码
               	    - 原码(负数)的符号位的数字不变，其余位数取反。 **原码** 和 **反码** 的缺点是基准不唯一，也就是0的表示由两种。同时减肥运算相较于加法运算更加麻烦。
       
             - 补码
               	    - 原码(负数)的反码加1。比如 +0 的原码是 0000 0000， -0的原码是 1000 0000，而它们的补码都是 0000 0000。 这样不但基数统一了，同时可以把减法运算变为加法运算。
       
          - 在计算机中的一个特殊的数字  **1 000 0000**
       
            	    - 他如果是无符号数，则表示为 2 的 7 次方， 即为 128；
             - 如果是有符号数字
               	    - 其原码表示为： -0
               	    - 其反码表示为:   -127
               	    - 其补码表示为:   -128 (这个是规定，因为补码把 +0 和 -0 统一了，所以多了一个位置， 人为的定义其为 -128 )
       
    - #### 计算机的局限性
    
       计算机可以表示的数的范围称为 **表数**；受硬件的影响的关系，不管是以前的8位计算机还是现在的64位计算机，对于数字的表示都是有范围的。如果超出了这个表示的范围，则称为 **溢出**。
    
       - 对于 **溢出** 的判断方法
         - 无符号数：最高位是否进位
           - 比如: 1111 1111 + 0000 0001 = 1 0000 0000 最高位进位，溢出
         - 有符号数：最高位和次高位是否同时有进位，或者同时没有进位。(只指加减)
           - 比如：0111 1111 + 0000 0001 = 1000 0000  次高位向最高位 进1，而最高位没有进位， 溢出。
       - 符号二进制和十进制的转化
         - 有符号数的二进制转化，需要求出真值都再进行转换。如果改数是正值，则原码反码补码皆是真值；如果是负数，需要将反码以及补码转化成原码，在进行转化。

- ## 基本逻辑运算与逻辑门

    - #### 逻辑运算的概念

        逻辑运算就是指对一个或者多个 **陈述句** 的命题进行判断其是否正确的过程。比如

        1. **今天我吃早餐** 为真命题， 

        2. **今天我吃早餐了，早餐吃的是馒头**， 这个命题是两个简单命题构成的复杂命题，判断其是否正确需要两个简单命题同时成立。但是结果只可能是真或者假

    

    - #### 使用逻辑运算的原因

      之所以在计算机中使用逻辑运算，是因为逻辑运算的结果只有只有两个状态，真或者假。其可以简单的对应生活中很多物理上的东西。比如开关的开和关，电压的高电平和低电平。数学上的 0 和 1。

    

    - #### 复杂命题的关系

        如上述第二个命题，多个简单命题可以构成复杂命题，但对于各个命题或者命题与自身之间的关系有三种表示。

        1. 非，对于已经得到的结果取反。比如上述 *例1* 取反即为假。使用符号 **1** 表示。其的状态和开关取反状态一致。
        2. 或，两个命题只要有一个成立即可。比如 **他是美国人或者他是中国人。** 多个命题称为 **或门**，使用符号 **>=1** b表示。其可以想象成并联电路，只要一个接通，就会有电。**因为只要有一个状态是真，其余的命题的结果就对总的结果产生不了影响，所以或门也是短路性质的**
        3. 并。 两个命题需要全部成立。如 *例2*。多个命题称为 **与门** ，使用符号 **&** 表示。其可以想象成串联电路。一个断电，全部没电。**因为只要有一个状态是假，其余的命题的结果就对总的结果产生不了影响，所以与门也是短路性质的**
        
    - #### 复杂逻辑运算
    
        复杂逻辑运算就像在数学运算的复杂运算一样，都是有简单的加减符号(与，或，非逻辑)构成的。用的很频繁的逻辑运算有：
    
        1. 与非门
    
           与非门就是对输入的值进行与操作，最后取反。
    
        2. 或非门
    
           或非门就是对输入的值进行或操作，最后取反。
    
        3. 异或门
    
           异或门表示的状态就是 **相同取0，不同取1**，是有符号 **⊕** 表示。也可以把它记为 **不进位相加**。比如
    
           A = 1011 0111 
    
           B = 0100 1001
    
           A ⊕ B = 1111 1110，A，B最后两个1相加等于2，应该进位，但是忽略进位，如此如果没有进位，直接按正常的运法法则计算即可。
    
        4. 同或门
    
           异或门的结果取反。

- ## 章节小结

  考虑下述问题是否清楚的知道。

  1. 微处理器，微型计算机，微型计算机系统三者有什么区别
  2. 计算机为什么要采用二进制，除了二进制还有什么其他的计算制
  3. 什么是有符号数，什么是无符号数
  4. 为什么要引入补码
  5. 冯诺伊曼计算机具有什么结构特点和基本工作原理
  6. 利用冯诺伊曼计算机执行一条指令的过程
  7. 什么是逻辑，真值表的含义
  8. 程序计数器PC的作用
  9. 不同计数制之间如何转换
  10. 原码，反码，补码之间的关系
  11. 二进制的运算
  12. 如何判断运算结果是否溢出
  13. 基本逻辑门电路的符号及输入与输出的关系
  14. 内存的组织模式
  15. **练习**：补码数 **A8H** 对应的十进制数是多少(注意：对于一个正数来说，原码=反码=补码；而对于负数则不是)；



- ## 8088/8086CPU

  - #### 为什么是8088/8086，它们的区别

    **8086芯片** 是第三代芯片，他的总线宽度为16位的，无论数对外或者对内，之前的芯片处理数据的能力是8位的。同时在8088/8086时代，该芯片也具备了并行流水的雏形，中断技术等等。更重要的是，如今的芯片和 **8086** 在重要的部分运行原理是一样的，都是使用冯诺伊曼体系。

    而 **8088与8086** 基本一致，只是对外，**8088** 为了兼容以前的软件等，采用的是8位总线。由于采用的是8位的总线，所以在引脚的一些地方是不同的。除此之外，**8088** 对内也是采用16位的总线，同时 **8088和8086** 使用的指令集是完全一致的。

  - #### 8088/8086相对于第二代芯片的特点

    - 采用了并行流水技术

      通过采用指令预取队列来完成，属于cpu内部结构的变化

    - 实现内存分段管理

      前面提及，内存是直接和cpu进行交互的，内存也被划分成一个一个具有相同存储字长的小格子。这些小格子具有固定的地址，cpu通过拿到某个小格子的地址，去找到这个小格子，获取里面的信息。

      而对于16位的处理器，其最多能表示2的16次方的地址也就是 64 k的地址，如果以这个标准，内存的容量就太小了。所以需要采取内存分段管理来达到内存地址由16位可以表达 1M ( 也就是 2 的 20 次方 )的内存。

      具体方法就是，将内存设置位4个段，并且设置内存寄存器。也就是实地址模式下的寻址。

    - 支持协处理器

      协处理器在今天已经看不见了，因为它已经集成到cpu里面去了。

      协处理器主要是用于浮点数的计算。因为以前都是定点计算，并不支持浮点运算，而定点计算的效率会低于浮点计算。

  - #### 8088/8086的工作模式

    因为支持协处理器，所以 8088/8086 支持两种工作模式： 最大工作模式，最小工作模式。

    - 最小工作模式
  
      只有主cpu在工作。由于控制信息都由主cpu完成，只有一个cpu工作，所以称为最小工作模式。其运行示意图如下：
  
      ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190617_1.png)
  
      因为8088对内存进行一次操作，首先是要知道要操作的内存信息的地址，其次是发出控制指令，在然后就是读取信息。所以8088发出内存信息地址，这时候，由于总线都是共用的，但是内存信息的地址不可以被覆盖，所以有一个ALE指令，将内存地址锁起来。避免其他信息通过产生的电平，将地址信息覆盖。
  
    - 最大工作模式
  
      由主cpu和协cpu一同工作。这个时候，所有的控制信息就不是都有主cpu发出，总线控制器会将一些由总cpu发出的指令分解然后传递出去。也就是总线cpu也担任了一部分产生控制指令的责任。
  
      以下是最大工作模式的工作流程:
  
      ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190617_2.png)
  
      对比于最小工作模式，多了总线控制器和数据收发的交互。
  
    - 判断在那个工作模式
  
      由 MN/MX 表示工作模式，处于哪个工作模式就在工作模式下电平就是个高电平.
      
      
    
  - #### 8088的主要引线及内部结构
  
    之前讲过，cpu完成一次指令的访问需要经过几个步骤
  
    1. 得到由 pc 所指的地址(地址可以在内存中，也可以在I/O接口中)
    2. 发出指令访问该内存地址
    3. 发出指令传输内存地址里面的数据(根据数据类型的不同做处理，如果数据是还是指令，则送去做指令译码等)
  
    由此可以知道，在完成这个过程需要分别对应下述三种信号
  
    1. 地址信号
    2. 控制信号
    3. 数据信号
  
    而8088在内部，总线的宽度为20，也就是有20根并行的总线，由此才能产生1M个不同地址码，管理1M的地址。但是对外8088只有8位宽度，所以遇到要传送16位的数据的时候，需要传送两次。对于20跟总线有以下三种分类：
  
    1. AD0 ～ AD7 表示数据通道(data)，用于传输低8位数据的。但是传输低8位地址信号也是使用它。它们属于分时复用。也就是错开时间使用。所以有上一章所提及的ALE信号来锁住地址信息，避免被数据信号冲掉。
    2. A8 ～ A15 8088处理器专有的地址信号
    3. A16 ～ A19 高4位的地址信号，和状态信号分时复用。<font color="red">这里所说的状态信号是不是就是控制信号呢？？？？</font>
  
    
  
    - 主要的控制信号
      - `#WR`
      - `#RD`
      - `IO/#M`
      - `#DEN`
      - `DT/#R`
      - `ALE`
      - `RESET`
    - READY信号
    - 中断请求和响应信号
      - 中断的意思是
    - 总线保持信号
      - 总线保持是为了
    
    
    
    - #### 8088内部结构
    
      - 8088内部结构分为 **执行单元(EU)**  和 **总线接口单元(BIU)**，如下图(这是示意图，不是原理图)
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190620_1.png)
    
      - 执行单元(EU)
    
        可以看见执行单元主要有4个部分组成
    
        1. 通用寄存器：暂存计算结果
        2. 运算器(ALU,算术逻辑单元)：执行指令
        3. FLAGS，标志寄存器：记录运算器在运算过程中的状态信息(比如有没有进位等)
        4. EU部分控制电路：指令译码
    
      - 总线接口单元(BIU)
    
        用于访问内存或者接口的部件。可以看见主要有以下部分
    
        1. 地址加法器：经过地址加法器从段寄存器中读入地址，在输出生成后的地址
    
        2. 指令队列：使得总线可以在 *EU* 工作的时候预取指令，达到并行工作(并行工作就是指: EU和BIU同时工作)的可能。
    
           对于预取队列，理想的情况是，第一次 EU传递给要取数据的地址， BIU取得数据，放入预取队列中，因为是第一个，所以队列为空，数据直接传递给EU进行指令译码。在EU指令译码，执行指令等过程中，BIU继续去取下一个指令放在预取队列中，EU上一个指令工作结束，马上可以从预取队列中获得下一个指令继续进行工作，从而实现不断流的并行工作。
    
           然而，这只是理想的情况。事实上，可以导致断流的因素有很多，比如
    
           1. 指令取过来，如果该指令需要数据，但数据没有取过来，所以 EU还需等待 BIU把需要的数据取来
           2. 如果取过来的指令是转移类指令，跳转到另外一个指令，则预取的指令依然不能用，需要去取跳转到的指令
    
      - 8088的进步
    
        总的来说：8088提高了运算的速率(有可能并行工作EU和BIU)，降低对存储器运行速度的要求(因为预取队列)
        
        
      
    - #### 8088内部寄存器
    
      1. 通用寄存器(8个)：**只要是通用寄存器就可以用来存放中间运算结果**
    
         - **数据寄存器** 有 4 个，由于8088是内部16位总线，所以处理数据可以达到16位。为了提高数据寄存器的灵活性，这 4 个寄存器分别是由 8 个8位的寄存器组成。比如 AX 由 AH 和 AL 组成； AH 和 AL是两个相互独立的寄存器，它们可以分开单独使用。但是当作为一个寄存器使用的时候，AH代表高 8 位的数据， AL 代表低 8 位的数据
    
           1. **AX** = AH + AL
    
              由于AX的效率相较于其他寄存器来说较高，所以一般用来在 I/O 操作的时候，和接口对接，传送消息。中间运算结果也多半会放在该寄存器中。AX里面的数据没有二义性，只可能是运算结果。
    
           2. **BX** = BH + BL
    
              在寻址的中用于存放基地址
    
           3. **CX** = CH + CL
    
              在循坏操作或者串操作的时候，用于存放计数值，比如说循环操作的时候，循环到第几次的次数就存放在这里面
    
           4. **DX** = DH + DL
    
              在间接寻址的 I/O 指令中存放 I/O 端口地址。在处理32位运算数时， 用于存放高 16位数。
    
         - **地址指针寄存器**
    
           1. **SP** 堆栈指针寄存器，其内容为栈顶的偏移地址，也是在堆栈操作的时候，其存放的地址总是指向栈顶，只要有堆栈操作，其就是专用寄存器 
           2. **BP** 基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址，在堆栈操作中，其可以指向栈中的任意位置
    
           **BX 和 BP 的区别在于 BX是活跃在数据段中；而 BP是活跃在堆栈段**
    
         - **变址寄存器** 变址寄存器在指令中常用于存放数据在内存中的地址
           1. **SI** 源变址寄存器
           2. **DI** 目标变址寄存器
    
      2. 段寄存器(4个) 用于存放逻辑段的段基地址
      
         - **CS** 代码寄存器
         - **DS** 数据寄存器
         - **ES** 附加段寄存器
         - **SS** 堆栈段寄存器
      3. 控制寄存器(2个)
         - **IP** 指令指针，在BI要取指令，会去看IP所指的位置，IP指向哪里就去哪里取？完全取决于程序计数器(IP)的指向的位置。所以 IP 称为指令指针，instruct pointer。
         - **FLAGS** 标志寄存器，用来存储运算结果的特征，比如有没有溢出等等。 只有9位有意义，其他7位是空闲位。
           - 状态标志位(6位):
             - **CF(carry flag)** 进位标志位，最高位有进位或者借位 1，表示无符号数计算溢出
             - **SF(sign flag)** 符号标志位， 运算结果最高位是 1， 为1；
             - **AF(Auxiliary carry flag)** 辅助进位标志位，在加减操作时，若bit3向bit4有进位或者借位，为1；
             - **PF(parity flag)** 奇偶标志位，运算结果的低8位中， 1的个数为偶数时，为1
             - **OF(overflow flag)** 溢出标志位，有溢出则为 1，表示有符号数计算溢出
             - **ZF(zero flag)** 零标志位， 运算结果为0的时候，为 1
           - 控制标志位(3位)
             - **IF(Interrupt Enable Flag)** 中断允许标志位，当其为1时，使CPU可以响应可屏蔽中断请求
             - **TF(Trag Flag)** 陷进标志位，当其为1时，cpu单步执行
             - **DF(Direction Flag)** 方向标志位，在数据串操作时确定操作的方向
      
      
    
    - #### 实模型下的存储器寻址
    
      - 内存储器管理
    
        由于8088时一个16位的芯片，所以无论是他的总线宽度，并行处理数据的位数都是16位的。这意味着，它可能同时管理2的16次方也就是64k个地址。但是64k的个地址实在是太小了。所以，需要有一个办法来提神其管理的容量。
    
        借助大楼的思想，在一层的房间都是以1开头，二层的则是以2开头。可以在内存地址中，在16位的前面加上4位区域地址，就可以管理 1M 内存了。
    
        但是这个管理方法有缺点：
    
        1. 因为cpu是16位的，而如果要使用4位的区域地址，而需要在添加专门的4位的寄存器，总线等等。与原本的cpu的体系格格不入
        2. 这个办法会导致单位内存利用率低下，比如，在一块内存中，如果一块内存被占用了。但是实际上它用不到那么大的内存，这会导致内存的浪费。
        
      - 内存单元的编址
      
        也是把内存分为一个一个的区域，为每个区域编上编号，再在每个区域中定义一块内存在该区域中所占据的位置。每个区域的编号就是段基地址，而在该区域中的位置，采用偏移地址的方式。也就是指定地址距离第一个地址的距离，称为段内地址。
      
        - 段基地址
      
          指存储单元在整个内存空间中处于哪个区域。8088只有4种区域，也就是4种段基地址，分别存在段寄存器中，每个逻辑段中存储单元的数量最多不超过 **64k**个：
      
          1. 代码段 存放指令代码
          2. 数据段 存放操作的数据
          3. 附加段 存放操作的数据
          4. 堆栈段 存放暂时不用但需要保存的数据
      
        - 段内地址
      
          指存储单元在段内的相对地址，也就是距离段内第一个存储单元的偏移量
      
        **无论是段基地址还是段内地址，都是16位的。**
      
        - 段首
      
          段首就是指在一个段中第一个存储单元，由于其相对于自己的偏移量是0，所以段首的段内地址就是0 。
      
        **所以得到的结论就是，一个存储单元的地址 = 该存储单元所在段的段首地址 + 偏移地址**
      
        由于段首地址的偏移量是 0；所以16位0，4位0，1位0都是0。 而对于管理 1M 个内存单元来说， 只需要20位即可。所以在 **内存分段的时候，每个段的段首，都是以节为边界来起始的，也就是说任何一个段的段首地址都要能够被16整除** 的前提下，可以将16位的 0 转写成4位的 0。
      
        - 物理地址
      
          独一无二的内存地址，也就是说，每个内存其实都是有一个独一无二的内存地址的。如果我们的技术可以做都内存中有 1M个内存单元，也就是说有 1M个客观存在真实内存地址。我们要怎么去使用 16位的cpu去管理这 1M的内存单元呢。
      
          基于上述的 **段基地址**， **段内地址**， **段首地址**，就可以由 16位的cpu去管理 20位的地址。
      
          所以物理地址 = 段首地址 + 段内地址(偏移地址)。
        
      - **总结一下**： 在8088中，所使用的内存芯片的大小是 1M，所以每个内存地址最少要用 20位( 2的20次方 )来表示。并且，每个内存单元都对应着 **唯一的，确定的，<font color="red">不变的</font>** *物理地址*。也就是说，在 8088中，如果一个内存地址是20位，那这个地址一定是某一个内存单元的 **<font color="yellow">物理地址</font>**。
      
        而物理地址又是由 **段基地址(16位)** + **段内地址(16位)** 所得。而 **段内地址** 指的是所使用的内存地址距离第一个内存单元( **段首地址**)的偏移量，所以 **段首地址** 就变成找到所使用内存单元的一个重要条件。但是 **段首地址** 也是存放在内存中的，它也有具体的物理地址，而他自己对于自己的偏移量是 **0**； 所以，段首地址就等于 **段基地址向左偏移16位**；由于 **16位的0，也是0，4位的0也是0；1位的0也是0**，而 8088的内存单元的物理地址是 20位的，所以在 **<font color="red">8088中，内存单元的物理地址是由20位组成，而所有20位的地址一定是内存单位的物理地址</font>**
        
        比如在8088中，一个段基地址是 2309H
        
        他的逻辑段首地址是 2309 : 0000 H
        
        他的物理段首地址是 23090H
        
      - 例子
      
        - 设某个数存放在数据段中，段基地址 DS = **250AH** ,数据所在单元的偏移地址是 **0204H** ，数据的物理地址是多少。
      
          **物理地址 = 段首地址 + 偏移地址**
      
          段基地址： 250A0 H (向左移动4位，由16进制表示就是一位，所以在后面加一个 0 )
      
          偏移地址： 0204H
      
          物理地址：250A0 + 0204 = 252A4H
      
        - 已知 **CS=1055H**, **DS=250AH**, **ES=2EF0H**,**SS=8FF0H**，画出各段在内存中的分布(默认每个段的大小是 64K)
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190702_1.png)
      
          
      
      - 由于逻辑地址的是由 **段基地址** 加上 **偏移地址** 组成，这两个地址都是逻辑上的，并且 **段基地址** 是存储在段寄存器中的，这意味着 **段基地址** 是可以变化的，这就使得一个段的位置可以在内存中路灵活的变换。同时，一个内存单元的的地址是由偏移量所决定的，这使得一个段可以和一个段相互交叉，一个内存地址可以分时被两个段所使用。
      
      - #### 逻辑段和逻辑地址
      
        - 内存的分段是逻辑分段，不是物理分段。各个逻辑段在地址上可以不相连，可以部分重合，也可以完成重合。
        - 每个内存单元一定具有 **<font color='red'>唯一的物理地址</font>**，但可以 **<font color="red">多个逻辑地址</font>**
      
      - #### 操作系统和逻辑段
      
        逻辑段之所以是采用 段基地址 + 偏移地址 来表示，这是由于操作系统的原因，我们写好的程序在不使用的时候是放在硬盘中的，在使用程序的时候，操作系统会把程序代码读入到内存中，插入内存的方式是见缝插针式的。所以想要表示出一个内存的地址，就要知道它是什么类型的代码，存放在哪个区域，距离该区域的段首地址的偏移量是多少。
      
        在电脑中，段基地址是由操作系统来控制的。
      
      - #### 堆栈段
      
        - 内存中一个特殊区域，用于存放暂时不用或需要保护的数据
        
        - 常用于响应中断或子程序调用
        
        - 指针
          - 栈顶 SP，SP (地址指针寄存器)指向栈顶的位置
          - 栈底 SS，SS是堆栈寄存器的段基地址
          
        - 例 SS = 1000H，SP= 0100H，求栈顶地址
        
          段首地址为 10000H， 栈顶偏移地址为 0100H， 栈顶地址为 10100H
        
        - 例 SS = 1000H，该段最后一个单元位 10200H。则栈底偏移地址为？
        
          段首地址为 10000 H， 最后一个单元为 10200H， 偏移地址为 10200 - 10000 = 0200 Hs
          
          
      
    - ### 8088系统总线
    
      - #### cpu时序
    
        cpu时序指的是cpu在工作过程中的各个引脚信号在时间的关系。以以下8088的工作时序图为例
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_1.png)
    
        - 在该图中，x轴表示时间，y轴表示各个引脚信号在不同时间的幅值(高低电平)。
        - CLK 表示时钟，就像在 人类社会的时钟一样，计算机在运行的过程中，也需要一个时钟，CLK就是这个时钟
        - A19/S6 - A16/S3 表示 A19 - A16 与 S6 - S3 所分时复用的总线。这里表示的状态是总的如(A19-A16)的状态，并不是单一的某个总线的状态。
        - A15 - A8， AD7 - AD0 同理
        - ALE 表示地址所存信号， 高电平的时候有效， 单有总线输出的是地址信号的时候， ALE为高电平， 表示有效， 将地址信号锁存
        - IOM 表示读取信号的位置是接口还是内存
        - RD表示读信息， 低电平有效，当为低电平的时候，可以进行读操作
        - DT/R 读取方法
        - DEN 片选信息， 有效才能才信息读取进来cpu
    
      - #### 总线周期
    
        cpu访问一次内存或者接口所需要的时间，包括四个阶段，T1,T2,T3,T4。如果在一个周期内有延时则在T3后 main添加TW阶段，可以添加多个TW。
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_2.png)
    
      - #### 总线分类
    
        - 按照传送信息的角度
          - 地址总线
          - 数据总线
          - 控制总线
        - 按照层次分类
          - cpu总线，cpu总线的标准并不统一，所以如果将cpu与接口相连，对于接口的制作不利，所以cpu总想必须要与系统总线相连
          - 系统总线，有统一的标准，现在主要有两种，PEI和PEIC总线。连接cpu和接口
          - 外部总线，连接cpu与外接设备如键盘等
    
      - #### 总线结构
    
        - 单总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_3.png)
    
          单总线的结构的缺点很明显：
    
          1. 接口设备和内存使用统一条总线，为了迁就接口设备，会导致总线上的速度不会太快，从而降低计算机运行效率
          2. 总线上挂着多个设备，导致争用问题很严重
    
        - 双总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_4.png)
    
          将内存和cpu的交互与接口和cpu的交互的总线分开，提高了计算机的运行效率。但是接口与内存的的交互就必须要通过cpu控制，也就是软件进行控制，这样速度同样不会太快。
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_5.png)
    
          在内存和接口也连接一条总线，是的接口和内存可以相互访问。
    
        - 多总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_6.png)
    
      - ####总线功能
    
        - 传输数据
        - 仲裁功能
        - 出错处理
        - 数据驱动
    
      - #### 总线评价指标
    
        - 总线带宽 B/S
    
          单位时间里，总线所传送数据的能力
    
          总线带宽 = 总线宽度(如 8 位) * 工作效率( 传输数据的速度)
      
    
    
    
    - ## 指令系统概述与数据传送指令
    
      - ### 指令系统的基本概念
    
        - #### 指令及指令系统
    
          - 指令：指的是人对计算机发出的指令。
    
          - 指令系统：因为指令是人对计算机发出的，然而人和计算机是不可以直接沟通的，所以计算机可以识别的指令的集合就是该cpu的系统集合
    
          - 指令的兼容性：随着cpu的发展，cpu的指令会有所改变，但是后一代的cpu可以识别上一代的指令，这就是指令的兼容性。
    
          - 指令包含的信息以及格式
    
            - 包含的信息：分析指令的含义可以知道指令要包括： 从哪里来，去哪里，做什么三个部分
    
            - 格式： 操作码 [操作数] [操作数]
    
              这里的操作码就是该指令应该干什么，中括号表示操作数是可选填的。第一个操作数是目标操作数也就是去哪里，它可能代表一个含义也可能代表两个含义，一定代表的是地址，因为计算机每次操作完一个流程，必须要知道操作的结果放在哪里。它也可能同时表示目标地址和操作数。比如 add 5 3，5就表示地址和操作数。第二个操作数可能是数据也可能是地址码
    
            - 分类，无操作数指令和单操作数指令并不是真正的没有操作数，而是因为操作对象是默认的，所以隐藏起来了。
    
              - 无操作数指令
              - 单操作数指令
              - 双操作数追指令
              - 多操作数指令
        
            - 操作数的种类
        
              - 立即数 
        
                立即数就是一个常量，就是一个数字。可以直接被cpu使用。 **<font color='red'>由于立即数只是一个数，没有任何其他的含义，也就是不能表示地址，所以立即数不能作为目标操作数，因为目标操作数必须是一个地址</font>**
            
              - 寄存器地址
            
                在cpu中有专门存放运算中间结果的地方，称为寄存器比如(AX,BX …)；所以它表示一个地址。如果操作数是它，因为在cpu内，所以运算速度比较快。
            
              - 存储器地址
            
                如果操作数使用 `[]`中括号括起来的，就表示存储器地址，也就是操作数被放在了内存中。比如 `MOV AL [1210H]` 就表示把偏移地址为 1210H的单元里面的数字移动至 AL中。**<font color='red'>注意：一般我们都只会操纵存储单元的偏移地址，所以`[ ]`中，是偏移地址。</font>** 如果目标地址是一个16位的存储单元，则cpu会搬运 1210H以及 1211H 存储单元里面的内容。 **<font color='red'>也就是源目标数据的长度由目标操作数决定</font>**。
            
          - #### 寻址方式
        
            - 立即寻址
            
              说白了，就是操作数是立即数，只是以寻址的方式去分类。所以其的注意和立即数一样。
            
              立即寻址就是指操作的对象就是给出的操作数。比如 `MOV AX 1200H`；其中1200H就是一个操作数直接给出的。所以立即寻址一般是和代码一块放在代码段的。
            
              所以立即寻址不可以表示目标操作数。**<font color='red'>所有的寻址方式中，操作数的长度是8位还是16位是由另外一个操作数所决定的</font>**
            
            - 寄存器寻址
            
              指令存放在寄存器中。
            
              **数据通常是放在通用寄存器中的，偶尔会在段寄存器中，绝不会在控制寄存器中**
            
            - 存储器寻址
            
              数据存储在存储器中。需要注意三点
            
              1. 表现形式，由中括号 `[ ]` 包裹
              2. `[ ]`表示偏移地址，这个偏移地址不是真实的偏移地址，因为在编写程序的时候没有办法确定段基地址，只有在程序进行编译的时候，计算机会将计算出真实的偏移地址，由给出的偏移地址加上段基地址组成。
              3. 逻辑段的段基地址地址通过默认或者重设的方式给出
              4. 存储器操作数的字长并不确定。
            
              存储器寻址又包括
            
              1. 直接寻址： 指令中直接给出操作数的偏移地址 `MOV AX [1200H]`;
                 - 操作数位置与段重设：段地址默认是在数据段中的，但是允许段重设比如：MOV AX, ES: [1200H]；
              2. 间接寻址：**数据存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容**。也就是说，偏移地址存放在某一个寄存器中。`MOV AX [BX]`
                 - 间址寄存器：可以用来存放数据的间接地址，只有四个通用寄存器：**BX**, **BP**,**SI**,**DI**;
                 - 操作数的位置与段重设：
                   - 如果偏移地址存放在 **BX**, **SI**, **DI**; 则默认是在数据段中
                   - 如果偏移地址放在 **BP** 中，则默认在堆栈段中
                   - 同样可以通过段重设的方式重设数据存放位置(不包括将数据存放在代码段中)
              
            - 寄存器相对寻址
            
              操作数的偏移地址为寄存器的内容加上一个位移量： MOV AX, [BX+DATA], 也可以写作 MOV AX, DATA[BX], MOV AX [BX]DATA
            
            - 基址、变址寻址
            
              - 操作数的偏移地址： 一个基址寄存器( BX ：默认在数据段, BP ：默认在堆栈段 )的内容 + 一个变址寄存器( DI, SI )的内容；基址寄存器内存储的内容主要是段基地址，变址寄存器中存储的主要是偏移地址
            
              - 用途：**与相对寻址一样，主要是用于一维数组操作**
            
              - 例子: 下述地址表示偏移地址为 2200H，存储在数据段中。
            
                ```js
                MOV SI, 1100H
                MOV BX, SI
                MOV AX, [SI + BX]
                ```
            
            - 基址，变址，相对寻址
            
              - 操作数的偏移地址组成： 一个基址寄存器( BX ：默认在数据段, BP ：默认在堆栈段 )的内容 + 一个变址寄存器( DI, SI )的内容 + 位移量。
              - 用途：主要用于二维数组，表头，行地址，列地址
            
            - 隐含寻址
            
              - 指令中隐含一个或者两个操作数，也就说操作数是默认的。
              
            - 寻址练习
            
              - 设 DS = 6000H, ES = 2000H, SS = 1500H, SI = 00A0H, BX = 0800H, BP = 1200H, 字符常数 VAR 为 0050H。 说明以下各条指令源操作数的寻址方式及存储器操作数的物理地址。
                - `MOV AX, BX` 寄存器寻址, 寄存器操作数不存在物理地址，它只是一个符号而已。
                - `MOV DL, 80H` 立即寻址
                - `MOV AX, VAR[BX][SI]` 基址变址相对寻址，BX,BP存储段基地址，SI, DI存储着偏移地址。 所以偏移地址为。0800 + 00A0 + 0050 = 08F0; 由于有BX存在，所以默认存储在数据段中，所以段基地址为 DS 6000H, 段首地址为 60000H；则物理地址为 608F0 H；
                - `MOV AL 'b'` 立即寻址
                - `MOV DI, ES: [BX]` 段重设，存储器间接寻址。偏移地址 0800H, 段重设后段首地址为 20000H, 物理地址为 20800H 
                - `MOV DX, [BP]` 由于存储地址为 BP, 所以默认放在堆栈区，所以物理地址为 15000 + 1200 = 16200H
                - `MOV BX, 20H[BX] ` 存储器相对寻址,  地址存储在 BX 中，默认在数据段，所以偏移地址为 0800H + 2000H 即 2800H；物理地址为 60000H + 0820H = 60820H
                
                
            
          - ### 通用数据传送指令
          
            - 8086指令集
              - 数据传送
                - 通用数据传送指令(**不影响**标志位）
                  - `MOV dest, src` 双操作数
                    - 要求两个操作数必须等字长
                    
                    - 要求两个操作数不允许同时为存储器操作数
                    
                    - 两个操作数不允许同时为段寄存器( 也就是不允许将一个段寄存器的值赋予给另外一个段寄存器 )
                    
                    - 源操作数是立即数的时候，目标操作数不能是段寄存器( 也就是说段寄存器不允许使用立即寻址的方式赋值 )
                    
                    - IP 和 CS 不作为目标操作数，FLAGS一般也不作为操作数在指令中出现( IP是地址指针, CS是代码寄存器，一般不会作为操作数出现，一定不能作为目标操作数 )
                    
                    - 例子
                      - `MOV AL, BX` 错误，操作数不等字长
                      - `MOV AX, [SI]05H` **正确**
                      - `MOV [BX][BP], BX` **错误**，BX，BP 是存放基址的寄存器， SI，DI存放变址的寄存器。从寻址方式上来说，没有将基址寄存器中的地址赋予给基址寄存器的方式。只有基址变址。 
                      - `MOVE DS, 1000H` **错误**，不可以使用立即寻址的方式给段寄存器( CS，DS，ES，SS)赋值。
                      - `MOV DX, 09H` **正确**
                      - `MOV [1200H], [SI]` 错误，两个操作数同时为存储器操作数
                      
                    - 例子应用
                    
                      - 题目：将 `*` 的ASCII码 2AH 送入内存数据段1000H 开始的 100 个单元中
                    
                      - 解
                    
                        ```
                        MOV DI, 1000H ;SI,DI 为变址寄存器，SI为源变址寄存器，DI为目标变址寄存器
                        MOV CX, 64H
                        MOV AL, 2AH
                        AGAIN: MOV [DI], AL
                        			 INC DI
                        			 DEX CX
                        			 JNZ AGAIN
                        			 HLT
                        ```
                    
                        上述代码经过编译后，代码段以及数据段的情况如下
                    
                        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190729_1.png)
                    
                        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190729_2.png)
                    
                  - 堆栈操作指令
                  
                    - 堆栈操作的原则：先进后出，以字节为单位
                    - 堆栈操作指令`
                      - 压栈 `push OPRD`
                    
                        - 压栈就是先将栈顶指针减2，将操作数的高 8 位压入，再将操作数的第八位压入。此时指针向上移动 2 位。(进行堆栈指令的操作数一定是16位的)
                    
                          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190730_1.png)
                    
                      - 出栈 `pop  OPRD`
                    
                        - 将栈顶指针下移2个单位，依次读出单位里面的数。这个过程仅仅是一个读的过程，所以读出的操作数并不是真正的被删除掉，只是在读的过程中，栈顶指针下移，所以，这两个操作数对于本堆栈来说就是不存在的。
                    
                          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190730_2.png)
                    
                      - 堆栈过程中应该注意的事
                    
                        - 操作数必须是16位的
                        - 操作数的字长必须确定，如果是存储器操作数必须指定字长。寄存器的操作数字长cpu是知道的( 比如 AX 是16位的，AL是8位的)。不能为立即数。( **8086规定所有单操作数的指令，其操作数不可以是立即数** )。(对于压栈指令来说，其操作数是源操作数，对于出栈指令来说，其操作数是目标操作数。目标操作数是不可以使用立即数来表示的，因为立即数没有任何地址的含义)
                        - 不能从栈顶弹出一个字给CS（段寄存器中的代码段）
                        - PUSH和POP指令一般成对出现
                        - PUSH指令的操作方向是从高地址向低地址(因为要把高地址压入下面),POP指令的操作正好相反
                    
                  - 交换指令
                  
                    - 交换两个操作数的位置，从功能上来说，它可以被 MOV 指令或者堆栈指令所替代，但是交换两个操作数，交换指令只需要写一条，而 MOV 指令则需要写 3 条， 堆栈指令则需要写 4 条。
                    - 格式 `XCHG REG, MEM/REG`
                    - 对于操作数的要求，由于是互换两个操作数，所以，这两个操作数即是源操作数也是目标操作数，也就是说，交换指令的操作数不可以是立即数。同时由于两个操作数不能同时是存储器操作数，因为存储器操作数的字长不确定，所以，该指令的操作数有一个必须是寄存器操作数，剩下一个可以是寄存器或者存储器操作数。同时，不允许使用段寄存器。
                  
                  - 查表指令
                  
                    - 用于操作一维数组的指令，可以被 MOV 指令所取代。( 前面讲过，操作一维数组可以使用寄存器相对寻址，基址变址寻址 )
                    - 该指令是零操作数指令，格式 `XLAT`
                    - 该指令默认一下过程
                      - 使用 BX 里面内容作为表头地址
                      - 使用 AL 里面的内容作为偏移地址
                      - 将 BX 和 AL 里面的内容作为地址取出指定单位的内容
                      - 将指定单位的内容送给 AL
                      - 总结就是 BX + AL —> AL
                  
                  - 字位扩展指令
                  
                    - 该指令 **只针对有符号数**，对于无符号数只需要在高位加上足够多的零即可。该指令是用于扩展操作数的位数，比如把8位扩展到16位，把16位扩展到32位。
                    - 字节到字的扩展
                      - 格式 `CBW`
                      - 将 AL 的内容扩展到 AX
                    - 字道双字的扩展
                      - 格式 `CWD`
                      - 将AX内容扩展到 DX AX
                    
                  - 地址传送指令
                  
                    - `LEA` 取偏移地址指令(只是在本段中获取偏移地址，所以忽略段基地址)，取近地址指针。
                  
                      - 操作 将变量本身的16位偏移地址写入到目标寄存器。因为变量表示的是 **内存单元** 的符号地址，所以变量属于存储器操作数。而当程序中如果需要使用变量表示某个内存单元的偏移地址的时候，则需要使用该命令。
                  
                      - 格式 `LEA REG, MEM`, 该命令中，目标操作数是寄存器操作数，源操作数是存储器操作数
                  
                      - 作为寄存器操作数，存放的寄存器不可以是段寄存器，因为里面存放着段基地址。不可以是标志寄存器。原理上来说是要放在 8 个通用寄存器中间。但是，去的偏移地址的目的是 基址变址寻址，所以最好把偏移地址放在4个 间址寄存器(用于存放间接地址的寄存器， SI，DI，BX，BP)中间，这样可以方便后面的操作。
                  
                      - 与 `MOV` 指令的对比
                  
                        - `MOV` 指令获取的是变量所存储的内容，`LEA`获取的是变量本身的偏移地址。举个例子，有一栋房子 `house`，门牌号是 A220，里面放了一把椅子。使用 `MOV AX house` 搬运的是里面的椅子，而使用 `LEA AX house` 搬运的是门牌号 `A220`
                  
                        - 一个例子
                  
                          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190731_1.png)
                  
                        - `LEA`的应用
                  
                          - 题目： 将数据段中首地址为 MEM1 的 50 个字节的数据传送到同一逻辑段首地址为 MEM2 的区域存放。编写相应的程序段。
                  
                          - 解 
                  
                            ```
                            LEA SI, MEM1
                            LEA DI, MEM2
                            MOV CL, 50
                            NEXT: MOV AL, [SI]
                            			MOV [DI], AL
                            			INC SI,
                            			INC DI,
                            			DEC CL,
                            			JNZ NEXT
                            			HTL
                            ```
                  
                            
                  
                    - `LES`获取偏移地址指令，包括段基地址和偏移地址，因为是去别的段取数据，取远地址指针
                  
                      - 格式 `LES 通用寄存器 存储器操作数`
                      - 默认将源操作数的段基地址送到 `ES`, 偏移地址送到指定的通用寄存器
                  
                    - `LDS` 获取偏移地址指令，包括段基地址和偏移地址，因为是去别的段取数据，取远地址指针，与`LES`的不同之处在于，获取段基地址后，默认存储的地方不同。
                  
                      - 格式 `LDS 通用寄存器 存储器操作数`
                      - 默认将源操作数的段基地址送到 `DS`, 偏移地址送到指定的通用寄存器
                  
                  - 标志传送指令
                  
                    - `LAHF` 零操作数指令，将 `FLAGS` 的低八位装入 `AH`
                    - `SAHF` 零操作数指令，将 `AH`装入 `FLAGS` 的低八位
                    - `PUSHF` 零操作数指令，默认源操作数为标志寄存器中的数。压栈操作, 默认的目标操作数是堆栈段
                    - `POPF` 零操作数指令，默认源操作数为标志寄存器中的数。出栈操作, 默认的目标操作数是堆栈段
                  
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190731_2.png)
                  
                  
                  
                - 输入输出指令(**不影响**标志位）
                
                  - I/O端口： 端口实际上就是 cpu 在与外部设备进行交互的时候，存放在接口中的寄存器。与cpu内部的寄存器一样，端口可以直接被cpu所访问。实际上，仅仅是为了区分与cpu内部寄存器的区别，他才会被命名为端口的。 **<font color='red'>I/O接口中，用于存储数据，可以直接被CPU访问的寄存器</font>**。
                
                  - 计算机输入输出系统中可以包含若干接口控制电路(芯片), 每个接口中都包含 1个或 多个 端口。
                
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190801_1.png)
                
                  - 端口的寻址方式: 端口地址在指令中的表现形式
                
                    - 直接寻址，在8086中，当端口地址是 8 位的时候，源地址可以使用立即数表示。
                    - 间接寻址 ，在8086中，当端口地址是 16 位的时候，源地址必须由 DX( DX 不作为 `IN`或者 `OUT`指令的时候大多数是存放运算中间结果的，但是在`IN`或者`OUT`指令中出现的时候，一定是表示端口地址，在8086中，端口地址可以是 64K 个) 指定。
                
                  - 输入输出指令
                
                    - 指令功能： 从端口地址读入数据到累加器(AX或者AL，不包括AH)，或者将累加器的值输出到端口中
                    - `IN` 指令
                      - 格式 `IN acc, PORT` ，acc是个符号，表示累加器 AX / AL
                    - `OUT` 指令
                      - 格式 `IN PORT, acc` ，acc是个符号，表示累加器 AX / AL
                    - 例子
                      -  `IN AX, 80H` 端口地址为 8 位，可以通过立即数给予，寻址地址为 256 个。
                      - `MOV DX, 2400H` 在这个指令中， 2400H 仅仅表示 2400H。
                      - `IN AL, DX` 2400H在DX，DX在 `IN` 指令中，表示 将端口地址为 2400H的端口里的内容移至累加器 AL。
                      - `OUT 35H, AX` 将累加器 AX的内容移至端口地址为 35H的端口里。
                      - `OUT AX, 35H` 格式错误。 `OUT`的目标地址必须是端口地址，所以只能是立即数或者是 DX。
                
              - 算术运算
              
                算术运算指令普遍都会影响状态标志位( CF, AF, ZF, OF, PF, SF )
              
                - 加法运算指令
              
                  - 普通加法指令 `ADD`
              
                    - 会影响 6 个状态标志位
              
                    - 格式： `ADD OPRD1, OPRD2` 即 将 OPRD1 和 OPRD2 的值相加赋予 OPRD1.
              
                    - 例
              
                      ```
                      MOV AL, 78H
                      ADD AL, 99H
                      ;将 78H 与 99H 相加
                      ;转化成二进制为
                      ;   0 1 1 1 1 0 0 0
                      ; + 1 0 0 1 1 0 0 1
                      ; 1 0 0 0 1 0 0 0 1
                      ;由此可以看出状态标志位的转变
                      ; CF = 1 最高有进位
                      ; SF = 0 最高位为0
                      ; OF = 0 最高位和次高位没用同时进位或者借位
                      ; ZF = 0 不全为0
                      ; AF = 1 第四位想第五位有进位
                      ; PF = 1 第八位 1 的个数为偶数
                      ```
              
                      
              
                  - 带进位的加法指令 `ADC`
              
                    - 会影响 6 个状态标志位
                    - 格式  `ADC OPRD1, OPRD2` 即 将 OPRD1 和 OPRD2 的值相加赋予 OPRD1.
                    - `ADC` 和 `ADD` 的区别在于，`ADC` 用于多字节相加，因为其在计算过程中会附带状态标志位 `CF`， 所以使用前需要 `CF`先清零，为了防止 `CF`在加法之初就为 1
              
                  - 加1指令 `INC`
              
                    - 会影响 5 个状态标志位，不会影响 CF (carry flag, 进位符号位，表示最高位是否有进位或者借位)
                    - 格式 `INC OPRD`， `OPRD`不可以是立即数，也不能是段寄存器，因为其修改过程为 `OPRD` + 1 —>  `OPRD` ，一般用于程序中修改地址指针  
              
                  - 例
              
                    - 题目： 求内存数据段中 M1为首和M2为首的两个20字节数之和，并将结果写入M2为首的区域
              
                    - 解
              
                      ```
                      ;单字节
                      LEA SI, M1
                      LEA DI, M2
                      MOV CX, 20
                      CLC  ; 使得CF=0
                      NEXT: MOV AL [SI]
                      			ADC DI, AL
                      			INC SI
                      			INC DI
                      			DEX CX
                      			JNZ NEXT
                      			HLT
                      			
                      ;双字节
                      LEA SI, M1
                      LEA DI, M2
                      MOV CX, 10
                      CLC  ; 使得CF=0
                      NEXT: MOV AX [SI]
                      			ADC DI, AX
                      			ADD SI, 2
                      			ADD DI, 2
                      			DEX CX
                      			JNZ NEXT
                      			HLT
                      ```
              
                - 减法运算指令
              
                  - `SUB` 指令
              
                    - 格式 `SUB OPRD1, OPRD2`，即  `OPRD1` - `OPRD2` —> `OPRD1`
                    - 影响6个状态标记位，但不考虑借位状态，即不考虑 `CF`
              
                  - `SBB` 指令
              
                    - 格式 `SBB OPRD1, OPRD2`，即  `OPRD1` - `OPRD2` —> `OPRD1`
                    - 多用于多字节的相减，因为其考虑借位状态也就是CF，对应于加法运算中的 `ADC`
              
                  - `DEC` 指令
              
                    - 格式 `DEC OPRD1`，即  `OPRD1` - 1 —> `OPRD1`
                    - 只影响5个状态标识位，不影响 CF ( 对应于加法运算中的 `ADD` )
                  - 例
                  
                  ```
                    ; 延时(定时)
                    
                    			MOV BL, 2
                    NEXT1: MOV CX, 0FFFFH  ;这里 FFFFH 前面加 0，并不是表示地址，而是给编译器看的；如果一个立即数的最高位是 A～F，必须在前面加0，编译器才能认识。
                    NEXT2: DEC CX
                    			 JNZ NEXT2;
                    			 DEC BL;
                    			 JNZ NEXT1;
                    			 HLT;
                  ```
                  
                - `NEG` 指令
                  
                    - 格式 `NEG OPRD`，即  `0 - OPRD ` —> `OPRD`  
                    - 要求： 操作数为 8 / 16位寄存器或者存储器操作数
                    - 结论： 该指令在绝大多数情况下， CF = 1；表示有借位，只有在 `OPRD` 为 0 的时候， CF = 0；
                    - 补码知识回顾： 在计算机中，有原码 ，反码，补码。原码就是原来的数，反码就是对原码取反，补码(正数不变，负数就是在反码的基础上再减1)。为什么会出现反码和补码呢？因为在计算机中进行减法是什么不方便的，反码和补码的出现就是为了将减法转化为加法。其基于的原理就是时钟转动一圈之后就相当于重置了。因为计算机对于数的表示是有上限的( 8位，16位，32位等等)；当其超过了这个范围就会溢出，表现出来结果就是重置。所以对一个数，总是可以找到另一数与其对应。比如 时钟里的 3点； 就可以表示为 ( 24 - 21 )  因为 24 是一个周期，所以 3 等于 -21； 这里 3 就是原码； -21 就是补码。
                    
                  - `CMP` 指令
                  
                    - 格式 `CMP OPRD1, OPRD2` 
                    - 操作： 仅仅进行  `OPRD1 - OPRD2` 的操作，不会对操作数进行修改，也就是说，它**仅仅是用作影响标志位的**。
                    - 作用：一般是用做两个数比较大小。要注意的是，比较大小的时候，对比的两个操作数是有符号数还是无符号数。
                    - 比较大小
                      - 无符号数
                        - `CMP AX, BX` 
                        - 如果 AX  >=  BX;  不会产生借位， 所以 CF = 0；
                        - 如果 AX = BX； 不会产生借位，且其结果为 0；所以 CF = 0； ZF = 1；
                        - 如果 AX  < BX； 一定产生借位 CF = 1;
                        
                      - 有符号数
                        - `CMP AX, BX`
                        - 因为有符号数比较大小，需要考虑符号位，同时如果两个操作数符号不一样，相减则可能会产生溢出，所以两个数的大小由 OF 和 SF 共同决定
                        - OF (符号溢出标志) 和SF (最高位标志位) 状态相同(即异或为0) AX >= BX
                        - OF和SF状态不同(即异或为1) AX < BX
                        
                      - 程序例
                      
                        ```
                        		LEA BX, MAX
                        		LEA SI, BUF
                        		MOV CL, 20
                        		MOV AL, [SI]
                        NEXT: INC SI
                        			CMP AL, [SI]
                        			JNC GOON  ;CF = 0则跳转
                        			XCHG [SI], AL ;交换两个数
                        GOON: DEC CL
                        			JNZ NEXT
                        			MOV [BX], AL
                        			HLT
                        			
                        ```
                      
                  
                - 乘除运算法
              
                    - 与加减运算符的区别
                        - 在加减运算中，是否是符号数是通过看 `CF`,`ZF`,`OF`,`SF`来观察。而乘除运算中，有专门区分操作数是否有符号的助记符。
                        - 在乘除运算中，都是单操作数运算。
                        - 对于操作数的要求与加减法运算有所不同。
                    - 乘法指令
                        - 在乘法运算中，采用的是隐含寻址。隐含的是存放被乘数的累加器(AX，AL)以及结果输出的位置(AX或者DX)；也就是目标操作数为被乘数，目标操作数被隐藏了。默认的目标操作数是放在AX(或者AL)中。
                        - 要求：两个操作数的字长是一样的，也就是说如果给的源操作数是 8 位(1字节)，目标操作数也一定是 8 位(1字节)，同时不论他们运算的结果是什么，都用 16位(2字节)表示。同理 如果源操作数是 16位，则结果为 32位，高 16位存储在 DX中， 低 16位 存储在 AX中。
                        - 无符号数乘法指令
                            - 格式 `MUL OPRD`  `AL x OPRD` --> `AX` 或者 `AX x OPRD` --> `DXAX`
                        - 有符号数乘法指令
                            - 格式 `IMUL OPRD` `AL x OPRD` --> `AX`( AL 是商， AH是余数 ) 或者 `AX x OPRD` --> `DXAX`( AX 是商， DX是余数 )
                        - 指令执行原理
                            - 对操作数取补码
                            - 做乘法运算
                            - 将乘积按位取反加1
                    - 除法指令
                        - 在除法运算中，也采用的是隐含寻址。被除数隐含在AX,DX中
                        - 要求：被除数的位数一定是除数的两倍，比如如果除数是 8位，被除数必须是 16位。
                        - 无符号除法指令
                            - 格式 `DIV OPRD`  `AX / OPRD` --> `AX` 或者 `DXAX x OPRD` --> `DXAX`
                        - 有符号数除法指令
                            - 格式 `IDIV OPRD`  `AX / OPRD` --> `AX` 或者 `DXAX x OPRD` --> `DXAX`
              
                - 算术运算符小结
              
                    - 相同点
                        - 指令都会状态标志位，除了 `INC` `DEC` 不会影响 CF
                        - 对于操作数的要求都是：
                            - 如果是单操作数，操作数不可以是立即数，如果操作时存储器操作数，必须确定字长
                            - 双操作数的要求与一般指令一样
              
                - 程序例
              
                    ```
                    MOV SI, 1200H
                    MOV WORD PTR[SI], 8965H
                    MOV AL, [SI]
                    INC SI
                    MUL BYTE PTR[SI] ;BYTE PTR 确定字长为1字节，WORD PTR 确定字长为2字节，
                    ```
              
                    解释：将 1200H 立即数移入 SI； 将 双字节立即数 8965H 存入 SI中；将SI(地址为1200H)中的内容移入 AL；SI加一；将 单字节 SI与 AL相乘，结果存入 AX中。
              
                    即将乘积 3543H 存入 AX。
              
              - 逻辑运算和移位
              
                - 基本逻辑运算符
              
                  - 与、或、非
                  - 异或
                  - 说明：**除了‘非’运算外；逻辑运算会影响状态标志位。**在逻辑运算的过程中，每一个位都是相互独立的，也就是说不存在进位的情况，所以不会影响 AF的值。但是会影响 OF 以及 CF的值。虽然逻辑运算过程中，最高位不会有进位，也不存在溢出，但是会使得 OF=CF=0； 
                  - 对于操作数的要求与单/双操作数一样。
              
                - 逻辑运算指令
              
                  - ‘与’指令
              
                    - 格式 `AND OPRD1, OPRD2`, `OPRD1 AND OPRD2`--> `OPRD1`；有 0 则为 0。
              
                    - 应用
              
                      - 实现两个操作数按位相与
                      - 使得目标操作数的某些位不变，某些位清零
                      - 在不影响操作数的情况，使得 CF = 0; OF = 0; 
              
                    - 程序例
              
                      - 题目：从地址为 3F8H 端口中读入一个字节数，如果该数 bit1 位为1，则可以从 38FH 端口将 DATA为首地址的1个字输出，否则就不能进行数据传送
              
                      - 解
              
                        ```
                        			MOV DX 3F8H ;当端口地址超过8位的时候，必须将端口地址存放在DX中
                        WATT: IN AL, DX
                        			AND AL, 02H
                        			JZ WATT  ;ZF=1，转移
                        			MOV DX, 38FH
                        			MOV AX，DATA
                        			OUT DX, AX
                        ```
              
                  - 或运算指令
                  
                    - 格式 `OR OPRD1 OPRD2` `OPRD1`  OR `OPRD2` --> `OPRD1`, 有1则为1.
                  
                    - 应用
                  
                      - 实现两个操作数按位相或
                      - 使得目标操作数的某些位不变，某些位变成 1
                      - 在不影响操作数的情况，使得 CF = 0; OF = 0; 
                  
                    - 程序例
                  
                      - 题目：将一个二进制数 9 变为字符 '9'
                  
                      - 解
                  
                        ```
                        ;字符 9 的ASCII码为 39H
                        MOV AL 9H;
                        ；方案1
                        MOV AL 39H
                        ；方案2
                        ADD AL 30H
                        ；方案3
                        OR AL 30H
                        ```
                  
                  - 非运算
                  
                    - 格式 `NOT  OPRD`, 将操作数按位取反送回原地址
                    - 指令对标志位没有影响
                  
                  - 异或运算符
                  
                    - 格式 `XOR OPRD1 OPRD2` 无进位相加
                  
                  - ‘测试’指令
                  
                    -  格式 `TEST OPRD1 OPRD2`
                    - 执行与运算，但是计算结果不送回目标地址，也就是仅仅影响标记位
                    - 应用：
                      - 常用于测试某些位的状态
                  
                  - 程序例
                  
                    - 题目：从地址为3F8H的端口读入一个字节数，当概述  的 bit1，bit3，bit5同时为1时，可从38FH端口将DATA首地址的一个字输出，否则不能进行数据传送。
                  
                    - 解
                  
                      ```
                            LEA SI DATA
                            MOV DX 3F8H
                      WATT: IN AL, DX
                            AND AL, 2AH
                            CMP AL, 2AH ;或者 XOR AL，2AH
                            JNZ WATT
                            MOV DX, 38FH
                            MOV AX, [SI]
                            OUT DX, AX
                      ```
                  
                - 移位操作指令
              
                  控制二进制向左向右移动的指令
              
                  - 操作数： 移位指令在格式上是双操作数指令，但是实质上是单操作数指令。其目标操作数就是需要计算的操作数，但是源操作数是是要位移的次数。由此，该类指令的目标操作数必须是指定长度的存储器操作数或者寄存器操作数，源操作数如果是1，可以由立即数给出，如果不是1则必须存放在CL中。
                  - 非循环移位指令
                    - 逻辑左移
                      - 原理：对目标操作数进行乘法工作，移动移位乘以2。移动的时候最高位存放在CF中，最低位补0. 从本质上来说，逻辑左移和算术左移没有区别。在概念上来说逻辑左移和算术左移，前者针对无符号数，后者针对有符号数。
                      - `SHL OPRD 1`
                      - `SHL OPRD CL`
                    - 算术左移
                      - `SAL OPRD 1`
                      - `SAL OPRD CL`
                    - 逻辑右移
                      - 针对无符号数右移，最低位存放在CF中，最高位补0
                      - `SHR OPRD 1`
                      - `SHR OPRD CL`
                    - 算术右移
                      - 针对有符号数，最低位存放在CF中，最高位补的数是符号位上的数
                      - `SAR OPRD 1`
                      - `SAR OPRD CL`
                    - 应用
                      - 左移实现乘法
                      - 右移实现除法
                  - 循环移位指令
                    - 不带进位位的循环移位, 将要最高位(最低位)移动到CF同时移动到最低位(最高位)
                      - 左移 `SOL OPRD 1/CL`
                      - 右移 `SOR OPRD 1/CL`
                      
                    - 带进位的位循环移位 将要最高位(最低位)移动到CF，同时将CF的值移动到最低位(最高位)
                      - 左移 `SCL OPRD 1/CL`
                      - 右移 `SCR OPRD 1/CL`
                      
                    - 应用
                      - 用于对某些位状态的测试
                      - 高尾部分和低位部分的交换
                      - 与非循环移位指令一起组成32位或者更长字长数的位移
                      
                    - 代码例
                    
                      - 题目：在内存数据段 M1 为首地址的4个单元中存放了 4 个压缩 BCD码。要求：将这 4 个压缩 BCD码分别转换为 ASCII码。 并将转换结果存放在同一逻辑段、 M2为首的单元中    
                    
                      - 分析：
                    
                        压缩BCD码是使用 4 bit 的二进制来表示 1 个十进制数，要将其转化为ASCII 码，需要分开转化其高四位和低四位；ASCII码表示 0～9 的高四位是 0011；所以可以先将 BCD码高四位置0，再将高四位变为 0011；如此完成低四位的转化；高四位转移到另一个寄存器的低四位，同理进行转化。
                    
                      
              
              - 串操作
              
                - 说明： 串操作指令主要针对的是数据块或者字符串，由于数据量大，所以数据一般存储在存储器中，因此串操作实现了存储器到存储器的数据传送，也就是说对一串操作命令来说，其目标地址和源地址都是存储器操作数。
              
                  对于操作数来说，待操作的数据串称为源串，目标地址称为目标串；执行该指令需要确定：
              
                  - 串所在的区域
              
                  - 串的长度
              
                  - 串的首地址
              
                  - 操作的方向：由于串操作的操作数都是多字节的，所以，在操作的过程中不可能一次性完成操作，并且，在串操作的过程中，没办法自定义指针的指向，指针移动的方向都是已经在指令中定义的，只有在使用指令的最初来定义指针是增量移动还是减量移动
              
                  - 操作数要求
              
                    - 源串一般放在数据段，偏移地址由 SI 指定。允许段重设
                    - 目标串必须在附加段，偏移地址由 DI 指定
                    - 串长度值由 CX 指定
                    - 串的操作方向由 DF标志位决定，指令根据 DF状态自动修改地址指针；DF = 0表示增地址方向， DF = 1 表示减地址方向
              
                  - 重复前缀：串指令前面添加重复前缀可以重复执行该条串命令
              
                    - 无条件重复：常用于传送指令
                      - `REP` 当 CX 不等于 0时，`REP` 后面的指令将继续重复执行
                    - 条件重复：常用于运算类别指令
                      - 相等( 相减为0 ) 重复 `REPE` 或者 `REPZ`，CX 不等于 0并且 ZF = 1时，串指令重复
                      - 不相等 (相减不为 0 ) 重复，`REPNZ` 或者 `RPENE`，CX不等于0并且ZF = 0时重复
              
                  - 串指令
              
                    - 串传送指令: 将源数据串传送到目的地址
              
                      - `MOVS OPRD1, OPRD2`, `MOVS [DI], [SI]`，需要对源操作数进行段重设时才采用该条命令
              
                      - `MOVSB` 以 bit 为单位
              
                      - `MOVSW` 以字节为单位
              
                      - 程序例: 分别用 `MOV` 指令和 `MOVS` 指令编写将200个字节数据从内存数据段 MEM1 为首地址的区域送到同一逻辑段 MEM2 为首地址的区域中
              
                        ```
                        ;使用 MOV 指令
                        LEA SI, MEM1
                        LEA DI, MEM2
                        MOV CX, 200
                        NEXT: MOV AL, [SI]
                        			MOV [DI], AL
                        			DES CX
                        			INC SI
                        			INC DI
                        			JNZ NEXT
                        HLT
                        
                        ;使用 MOVS 指令
                        LEA SI, MEM1
                        LEA DI, MEM2
                        MOV CX 200
                        CLD ;将 DF 清零，于是重复传送指令的操作方向是增地址方向
                        REP MOVSB
                        HLT
                        ```
              
                    - 串比较指令：用于实现两个数据串的比较
              
                      - 使用 **目标串** 减去 **源串**； 结果丢弃，不写回目标地址
                    
                      - 常与条件重复前缀连用
                    
                      - `CMPS OPRD1, OPRD2`
              
                      - `CMPSB`
              
                      - `CMPSW`
                    
                      - 程序例
              
                        - 题目：测试上例中 200 个字节数据是否传送正确
                    
                        ```
                        ;使用 MOVS 指令
                        LEA SI, MEM1
                        LEA DI, MEM2
                        MOV CX 200
                        CLD ;将 DF 清零，于是重复传送指令的操作方向是增地址方向
                        REPE CMPSB
                        JZ STOP	;判断 ZF 是否等于 1； 等于 1 则跳转
                        DEC SI
                        MOV AL, [SI]
                        MOV BX, SI
                        STOP: HLT
                        ```
                    
                    - 串扫描指令：常用于在指定区域中寻找某个关键字
                    
                      - 格式
                    
                        - `SCAS OPRD`
                        - `SCASB`
                        - `SCASW`
                    
                      - 执行 `SCAS` 与执行 `CMPS` 指令相似。区别是这里的源操作数是 AX 或者 AL。
                    
                      - 程序例
                    
                        - 题目：在ES端中从 2000H 单元开始存放了10个字符，寻找其中有无字符 'A', 若有则记下搜索次数，将搜索次数写入到 DATA1 单元，并将存放 'A' 的地址写入 DATA2 单元
                    
                        ```
                        MOV DI, 2000H
                        MOV BX, DI
                        MOV CX, OAH
                        MOV AL, 'A'
                        CLD
                        REPNZ SCASB
                        JZ FOUND
                        MOV DI, 0
                        JMP DONE
                        FOUND: DEC DI
                        			 MOV DATA2, DI
                        			 INC DI
                        			 SUB DI, BX
                        DONE: MOV DATA1. DI
                        			HLT
                        ```
                    
                    - 串装入指令
                    
                      - 格式 
                        - `LODS OPRD` ，这里是源操作数，指针在 SI
                        - `LODSB`
                        - `LODSW`
                      - 操作：将 SI 中内容送给 AL/AX
                      - 作用是将内存中某个区域的数据串依次装入累加器，以便显示或输出到接口
                      - LODS 一般不加重复前缀，因为如果添加重复前缀，重复装入内容到累加器( AX/AL )，后面的内容会把前面的内容覆盖
                    
                    - 串存储指令
                    
                      - 格式
                        - `STOS OPRD`
                        - `STOSB`
                        - `STOSW`
                      - 操作：将 AL/AX 送到 DI 所指的位置
                      - 常用于将内存某个区域置同样的值
    
    - ### 程序控制类指令
        本质上：控制程序要不按照正常的顺序执行，而是改变程序的运行方向; 由于计算机运行的顺序是由 PC 也就是 IP 指针所确定的，同时运行的代码是一般是放在代码段中也就是 CS 中，所以，改变程序的走向也就是改变 IP 或者 CS 的值。所以，本章的重点在于 **程序如何修改 CS 以及 IP 的值**
        
        指令类别
        
        - 转移指令
        
            ​	通过修改指令的偏移地址，或者修改程序的段地址以及偏移地址来实现程序的转移
        
            - 无条件转移指令
        
                - `JMP OPRD` OPRD是目标地址
                    - 段内直接转移， 转移的目标地址由指令直接给出(立即数)。格式是 `JPM LABEL`; 下一条要执行的指令的偏移量地址是 当前 IP + IP到LABEL的位移量
                    - 段内间接转移，转移的目标放在某个16位寄存器或存储器的某两个单元中
                    - 段间直接转移，目标地址为32位，包括段基地址(高地址)和偏移地址(低地址)。格式是 `JPM FAR LABEL`；有
                        FAR表示远地址，也就是段基地址在其他段。
                    - 段间间接寻址，格式 `JMP DWORD PTR[BX]`
        
            - 条件转移指令
        
                满足一定的条件，是的程序转移到目标地址。转移范围是 ( -128 ~ 127 );    
        
                -  基于1个标志位状态实现转移
                  - `JC/JNC` 基于CF；常用于两个无符号数大小比较
                  - `JZ/JNZ` 基于 ZF；常用于循环体的结束判断
                  - `JO/JNO` 基于OF；常用于有符号数溢出的判断
                  - `JP/JPE`, `JNP/JPO` 基于PF；用于判断运算结果低8位中，1的个数是否为偶数
                  - `JS/JNS` 基于SF；常用于判断数的性质
                -  基于2个或者3个标志位状态实现转移
                   -  `JA/JAE/JB/JBE`；判断CF或CF+ZF的状态，无符号数比大小
                   -  `JG/JGE/JL/JLE`；判断SF+OF或者SF+OF+ZF的状态，有符号数比大小
                -  基于CX内容转移的指令
                   -  `JCXZ` 可根据指令执行后CX的结果实现转移 
        
        - 循环控制
        
            - 循环范围：以当前IP为中心的 -128 ～ +127 范围内循环
            - 循环次数：由CX寄存器指定
            - 循环指令
                - `LOOP LABEL` 无条件循环指令，LABEL是下一条要执行指令的地址，当 CX 不等于 0 时循环。该指令默认每一次循环会将 CX 减 1；
                - `LOOPZ LABEL` 同样在每次循环前会使得 CX 减 1，同时循环的条件时 CX 不等于 0， 同时也要看 ZF 的值；
                - `LOOPNZ LABEL` 同样在每次循环前会使得 CX 减 1，同时循环的条件时 CX 不等于 0， 同时也要看 ZF 的值；
        
        - 过程调用
        
            - 在汇编中，过程也称为子程序，过程调用也就是调用子程序。
            - 与转移指令的对比：过程调用结束后要返回原调用处，所以在调用子程序的时候，就要保护好原调用处。
            - 过程调用的过程：首先找到要调用的子程序的第一条命令的地址(入口地址)，执行子程序，结束子程序的执行后返回原调用处的下一条命令的地址(断点)。
                - 保护断点：将调用指令的下一条指令的地址(断点)压入堆栈。
                - 获取子程序的入口地址：子过程第1条指令的地址
                - 执行子程序：功能实现，参数的保存和恢复
                - 恢复断点，返回原程序：将断点偏移地址由堆栈弹出
            - 指令
                - 段内调用：被调用程序和调用程序在同一个代码段中，所以段内调用不需要保护段基地址，只需要保护偏移地址。
                    - 直接调用：与间接调用的区别在于，子程序的入口是直接给出的还是间接给出的。
                      - 格式 `CALL TIMER` 用一个标签 TIMER 表示偏移地址
                    - 间接调用
                      - 格式 `CALL WORD PTR[SI]` 
                - 段间调用：子过程与原调用程序不在同一代码段，调用前需要保护断点的段基地址和偏移地址。保护段基地址和偏移地址是指吧他们压入堆栈，先压入断点的CS(段基地址)，再压入IP ( 偏移地址 )
                    - 直接调用
                      - 格式 `CALL FAR TIMER`
                    - 间接调用
                      - 格式 `CALL DWORD PTR[SI]`
                - 返回指令
                    - 功能： 从堆栈中弹出断点地址，返回源程序
                    - 格式 `RET`
                    - 子程序最后一条指令必须是 `RET`
        
        - 中断控制
        
            - 中断的概念
                - 因为一些异常或者随机事件，迫使cpu停止正在运行的程序，转而去执行一段特殊处理程序，并在处理结束后返回原程序被中断处继续执行原程序的过程。
                - 中断指令：引起CPU产生一次中断的指令
            - 中断与过程调用
                - 相似点，中断和子程序调用都是cpu在执行原代码的时候，保护断点后，转而去执行另外一段代码，执行结束后会返回原程序。
                - 区别
                    - 过程调用是有程序员设计好的，是事先就可以很清楚的知道什么时候发生的。而中断是一种随机的，异常的状况发生后，cpu转而去执行一段专门应对与该种状态的代码。处于这种原因，一般程序员编写中断代码的时候可能会出现两种原因：1、异常发生，永远不希望被执行的代码；2、随机发生，不知道什么时候会发生的事情。
                    - 子程序的入口给出方式不一样，过程调用是由代码直接或者间接的给出的；而中断只是给出了子程序的入口的向量码，入口地址则在向量码只想的内存单元中。
                    - 过程调用可以是近地址或者远地址，中断一定是远地址，也就意味着断点保护一定包括段基地址和偏移地址。
                    - 中断请求还需要保护 FLAGES 的内容
                - 指令
                    - `INT n` n是一个状态码，范围 0～255； n * 4 以及 n * 4 + 1 表示存放中断服务子程序入口地址的单元的偏移地址;  n * 4 + 2 以及 n * 4 + 3 表示段地址
                - 指令指令过程
                    - 将 FLAGES 的内容压入堆栈
                    - 将中断命令下一条指令的 CS，IP压入堆栈
                    - 获得中断命令的向量码：n * 4；
                    - 将中断程序的 IP， CS 放入寄存器中
                    - 执行中断程序
                - 中断返回指令
                    - `IRET`：恢复断点，恢复标志寄存器内容
            
        - 处理器控制指令
        
            用来对CPU进行控制。比如修改标志寄存器，使CPU暂停，使CPU与外部设备同步等。
        
            - `CLC`: CF -> 0
            - `STC`: CF -> 1 
            - `CMC`: CF取反
            - `CLD`: DF -> 0
            - `STD` DF -> 1
            - `CLI` IF -> 0
            - `STI` IF -> S

- ## 汇编语言源程序

  - #### 汇编语言源程序: 由汇编语言编写的程序代码，后缀名: .ASM

  - #### 汇编程序: 将汇编语言源程序转变成电脑可识别的机器语言的一个系统程序，后缀名: .OBJ

  - #### 链接： 将汇编程序中所需要的各个库进行装入，生成一个可执行的文件，后缀名: .EXE 

  - #### 汇编语言语句语句类型和格式

    - 语句类型

      - 指令行语句: CPU 执行的语句，能够生成目标代码
      - 指示性语句: CPU不执行的语句，比如怎么样分配内存空间，程序从哪里开始到哪里结束。是由汇编程序执行的语句，不生成目标代码

    - 汇编语言语句格式

      - 指令行语句: `[标号:] [前缀] 助记符 [操作数], [操作数][；注释]`

        以上方括号表示，可以有可以没有，即可选项。标号后面必须要有冒号。
        
      - 指示性语句: `[名字] 伪指令助记符 操作数 [, 操作数, 操作数, ...] [; 注释]`
      
        **名字** 后面不接 **冒号**，指示性语句至少有一个操作数，可以有多个，大小限制就是不可以超过所在段的段大小。
      
    - 汇编语言语句中的操作数
    
      - 寄存器操作数
      - 存储器操作数
      - 常量：数字常量，字符串常量；
      - 变量和标号
        - 变量：内存单元的符号地址，是存储器操作数，属性：段值，偏移量，类型(字节型，字型，双字型)；
      - 表达式：算术运算，逻辑运算，关系运算，取值运算和属性运算(`PTR`)，其他运算
    
  - #### 数据定义伪指令
  
    - 伪指令：由汇编程序指令的 **指令系统**。不会被翻译成机器语言。目的：帮助计算机理解汇编语言源程序
  
      - 作用：
  
        - 定义变量
        - 分配存储区
        - 定义逻辑段
        - 指示程序开始和结束
        - 定义过程
  
      - 常用伪指令
  
        - 数据定义伪指令
  
          - 定义数据区中，变量的类型以及所占用内存的大小，存储的过程都是有低地址向高地址的顺序。
  
          - 格式 `[变量名] 伪指令助记符 操作数, ... ;[注释]`
  
            - `DB` ( Define Byte ) 定义的变量为字节型
            - `DW` ( Define Word ) 定义的变量为字类型
            - `DD` ( Define Double Word) 定义的变量为双字型
            - `DQ` ( Define Quadword ) 定义的变量为4字型
            - `DT` ( Define Tenbytes ) 定义的变量为10字型
  
          - 例
  
            - `DATA1 DB 11H, 12H, 13H`
            - `DATA2 DW 11H, 12H, 2323H`
            - `DATA3 DD 23h * 2, 2323H, 23235656H`
  
            可以看的出，上述变量的类型声明之后，如果给变量所赋的值是 11H， 但是其伪指令助记符为 `DW`, 则其应该是 0011H。在内存中的存储形式也应该是这个样子的。
  
          - 说明
        
      - 定义字符串必须由 `DB` 来定义。
    
  - 重复操作符号
        
          - 作用：为一个数据区的各单元设置相同的初值
          - 格式：`[变量名] 伪指令助记符 n DUP (初值 [,初值 ...])`; n表示重复的次数，DUP表示重复的运算符，初值是重复的内容
          - 例 
      - `M1 DB 10 DUP (0)`, 定义了一个以 M1 为初始地址的，10个变量，初始值全部为 0；
      
  - 问号 `?`
        
          - 表示随机值，用于预留存储空间
          - 例
      - `MEM1 DB 34H, 'A', ?` 也就是表示一个占位符。
      
  - 符号定义伪指令
        
    - 将表达式的值赋给一个名字。当源程序中需多次引用某一表达式时，可以利用 `EQU` 伪指令， 用一个符号代替表达式，以便程序维护。
          - 格式： `符号名 EQU 表达式`， `EQU` 就是 equal 的缩写。
    - 操作： 用符号名取代后面的表达式，类似于给变量赋值，但是与变量不一样的是，变量在后期可以重新定义，而符号不可重新定义。同时， **采用该方法系统不会给符号在内存中分配空间，但是如果是给一个变量赋值，系统会在内存中给该变量分配存储空间**。
      
      - 例 `CONSTANT EQU 100`, CONSTANT 就表示 100。如果要改变值，就要重新编译。
      
        - 段定义伪指令
        
          - 作用：在汇编语言源程序中定义逻辑段，说明逻辑段的起始和结束，不同程序模块中同类逻辑段的联系形态。
          
          - 格式： `段名 SEGMENT [定位类型] [组合类型] ['类别']`
          
            ​					`  ...`
          
            ​			`段名 ENDS`
          
            - 段名：逻辑段的段基地址
            - `SEGMENT`：指的是代码片段
            - 定位类型：逻辑段的起点
            - 组合类型：装入内存时，不同的逻辑段的组合方式，默认不组合
            - 类别：字符串，链接的时候，不同程序模块中的同类逻辑段将被装入连续存储区中
          
          - 程序例
          
            ```
            DATA SEGMENT ;段基地址由于是由操作系统统一分配，程序员不能自行设定，所以段名使用符号代替,这里没有指定是哪一个逻辑段，只是把他们都放在同一个逻辑段中
            	MEM1 DB 11H, 22H
            	MEM2 DB 'HELLO'
            	MEM3 DW 2 DUP (?)
            DATA ENDS
            ```
          
          - 设定段寄存器伪指令
          
            - 说明所定义逻辑段的性质
            - 格式 `ASSUME 段寄存器名：段名 [, 段寄存器名：段名]`，段寄存器名就是四个段寄存器: CS, ES...
        
        - 结束伪指令
        
          - 表示程序结束
          - 格式： `END [标号]`
        
        - 过程定义伪指令
        
          - 定义一个子过程
          
          - 格式
          
          ```
          过程名 PROC [NEAR/FAR]
          
          ...
          			RET ；return 指令，不可省略
          过程名 ENDP
          ```
          
           **过程名** 代表着这个过程的入口地址。 **NEAR/FAR** 表示为 近过程体(可以省略) / 远过程体
          
        - 调用例
        
          ```
          ;定义延时子程序
          DELAY PROC    ；声明的子程序符号
          			PUSH BX ；在该子程序中会使用 BX以及 CX两个通用寄存器，为了通用的原则，所以在开始程								序之前必须要保护那些被使用的寄存器或者其他的值，这里需要把 BX 和 CX中的值								保存下来，以便结束该子程序的时候可以还原，不会影响其他程序的执行
          			PUSH CX
          			
          			MOV BL, 2      ；执行定时子程序的代码
          NEXT: MOV CX, 4167
          W10M: LOOP W10M
          			DEC BL
          			JNZ NEXT
          			
          			POP CX				；还原现场
          			POP BX
          			RET 					；return
          DELAY ENDP
          
          ；调用子程序
          CALL DELAY
          ```
        
          
        
        - 宏命令伪指令
      
            - 宏：源程序中由 **<font color='red'>汇编程序识别的</font>**  **<font color='orange'>具有独立功能</font>** 的一段 <font color='yellow'>程序代码</font>
      
            - 使用场景： 当源程序中需要多次使用同一个程序段时，可以将该程序段定义为一个宏
      
            - 宏与子程序的异同：
      
                - 相同点：都是具有独立功能的一段程序代码，类似于函数
      
                - 不同点：子程序不依赖于特定的一个源程序，通过编译链接可以被任何的源程序所使用，也就是说，子程序可以被编译链接成一个独立的可执行的文件。但是宏不行，虽然宏也是一段独立的程序代码，但是宏只能是特属于某一个源程序，但是在该源程序反复使用，所以被提炼出来。但是只能被该源程序所调用，通过参数传递的方式来调用的。
      
                - 格式： 
      
                  ```
                  宏命令名 MACRO <形式参数>
                      .... ；宏体
                          ENDM
                  ```
      
                  ```
                  DADD MACRO X,Y,Z
                  	   MOV AX, X
                  	   ADD AX, Y
                  	   MOV Z, AX
                  	   ENDM
                  	   
                  ；调用宏
                  DADD DATA1, DATA2, SUM
                  ```
      
              - 调用形式，系统在编译的过程中会将调用宏的命令用宏体来替代，这个过程称为宏展开。所以，使用宏之后，不会减少代码编译完成后的文件大小，只会减少编写的时候的书写量。上述代码宏展开后为
      
                ```
                MOV AX, DATA1
                ADD AX, DATA2
                MOV SUM, AX   
                ```
      
      - 调整偏移量伪指令
      
        - 规定程序或变量在逻辑段中的起始地址，默认条件下，程序或变量在逻辑段中的起始偏移地址为 0；
      
        - 格式 ：`ORG 表达式` 表达式的结果一定要是一个非负的常数
      
        - 例
      
          ```
          DATA SEGMENT
          		ORG 1200H
          		BUFF DB 1,2 ;如果不使用 ORG 命令，变量 BUFF 的偏移地址为0， 使用之后， BUFF 的偏移									地址变为 1200H
          DATA ENDS
          ```
      
          
      
        - 汇编语言源程序结构
      
          ```
          数据段名 SEGMENT
          	...
          数据段名 ENDS
          附加段名 SEGMENT
          	...
          附加段名 ENDS
          堆栈段名 SEGMENT
          	...
          堆栈段名 ENDS
          代码段名 SEGMENT
          	...
          代码段名 ENDS
          				END
          ```
      
          ```
          DSEG SEGMENT ;定义数据段，如果使用内存则必须定义
          	DATA1 DB 1,2,3 DUP(?)
          	DATA2 DW 1234H
          DSEG ENDS
          
          ESEG SEGMENT ；定义附加段，如果使用串操作则必须定义
          	DB 20 DUP (?)
          ESEG ENDS
          
          SSEG SEGMENT	；定义堆栈段，如果使用中断指令，异常处理则必须定义
          	DB 200 DUP (?)
          SSEG ENDS
          
          CSEG SEGMENT	；定义代码段
          	ASSUME CS: CSEG, DS: DSEG, ；将定义的逻辑段分别赋给段寄存器
          				 ES: ESEG, SS: SSEG
          
          START: MOV AX, DSEG	； 完成上述操作，计算机并不会为代码分配内存，必须初始化，也就是通过通用寄											  存器给段寄存器赋值
          			 MOV DS, AX
          			 MOV AX, ESEG
          			 MOV ES, AX
          			 MOV AX, SSEG
          			 MOV SS, AX
          			 
          			 ... ;一些执行代码，要执行的源程序在写在该处
          			 
          CSEG ENDS
          		 END START ；必须写的程序结束命令， START 表示标号，START标记的地方是程序开始的第一段代									 码。标号可以自定义，也可以是 NEXT 或者其他。
          ```
      
    
  - #### 系统功能调用
  
      系统功能调用主要是指调用 **系统BIOS** 或者 **系统内核** 的一些 **功能**。
  
      - BIOS (Base Input Output System 基本输入输出)
        - 定义：驻留在 ROM 中的基本输入输出系统。他是一段程序代码，随着芯片出厂便附着在芯片上，随着开机会自动运行。早起的 BIOS 是使用光刻技术刻在芯片上的，所以早期的 BIOS 是不可以被修改的，只允许被砸烂。现代的 BIOS 是存储在可写的只读硬盘里。
        - 功能： 
          - 加电自检，开机后，BIOS 系统会引导计算机进行自我检测。
          - 装入引擎，BIOS会运行操作系统程序，将操作系统的程序由硬盘引导到内存中。BIOS 中存储开机后运行第一条指令的地址，即 IP 指针的初始值时候 BIOS 赋予的。
          - 主要 I/O 设备处理程序及接口控制，BIOS会接管主要的输入输出接口等。
      - DOS (磁盘操作系统)，DOS带有一般的BIOS功能，BIOS是更为底层的功能
      - 调用 BIOS 和 DOS 
        - DOS功能 / BIOS功能的调用都是通过调用系统内核子程序
        - DOS功能 / BIOS功能均通过 **中断方式调用**， 称为 DOS / BIOS 中断
      
  - #### DOS软中断
  
      - DOS中断包括 设备管理、目录管理、文件管理以及其他，他们依靠中断类型码区分。DOS软中断的类型码是 21H。
  
      - DOS软中断中包括了许多个具有不一样功能的子程序，调用这些子程序所使用的中断码均为 21H，但是子程序之间是使用 **功能号** 进行区分的。
  
      - 调用子程序的基本步骤
  
          - 将调用参数装入指定的寄存器，DOS系统是不开源的，所以，它提供了入口参数/出口参数，调用的时候需要按照要求配置入口参数。
  
          - 将功能号装入 AH。将需要调用的子程序所对应的功能号装入 AH寄存器中。
  
          - 按照中断类型号调用 DOS 中断，各个参数配置完毕后，调用 DOS 中断。
  
          - 检查返回参数是否正确
  
          - 调用格式为
  
              ```
              MOV AH 功能号
              	<置相应参数>
              INT 21H
              ```
  
      - 子程序调用实例
  
          - 单字符输入
  
              - 调用方法
  
                  ```
                  MOV AH, 01
                  INT 21H
                  ```
  
              - 这个子程序的入口参数是由键盘输入的，所以不用设置，出口参数是存储在AL中，出口参数也就是你在键盘上敲入的字符。
  
              - 例
  
                  ```
                  ;输入 N/Y 汇编程序例
                  GET KEY: MOV AH, 1
                  				 INT 21H
                  				 CMP AL, 'Y'
                  				 JZ YES
                  				 CMP AL, 'N'
                  				 JZ NO
                  				 JMP GET KEY
                  	  YES: ...
                  	   NO: ...
                  ```
  
          - 字符串输入
  
              - 说明
  
                  - 接受由键盘输入的一串字符串
                  - 输入的字符串存储在内存指导区域中(字符输入缓冲区)
                  - 字符串要放在字符输入缓冲区必须要依照下列格式存放，这是规定好的
                      - N1(最大可输入字符数) , N2(实际输入字符数), ....(输入的字符), ODH(回车的ACSII)
  
              - 字符串输入所对应的功能号是： 10
  
              - 字符输入缓冲的定义必须放在数据段中，并将偏移地址送个 DX，也就是定义的逻辑地址存放是 DS : DX
  
              - 程序例
  
                  ```
                  DAT1 DB 20, ?, 20 DUP(?) ;输入缓冲区的定义
                  	...
                  LEA DX, DAT1 ;将输入缓冲区的偏移地址送给DX
                  MOV AH, OAH  ;将字符串的功能号送个 AH
                  INT 21H			 ;调用DOS软中断命令  
                  ```
  
          - 单字符输出
          
              - 输出设备是显示器
          
              - 功能号是 2
          
              - 待输出字符存储在 DL 中
          
              - 程序例
          
                  ```
                  MOV AH 02H
                  MOV DL 55H
                  INT 21H
                  ```
          
          - 字符串输出
          
              - 功能号： 9
          
              - 待输出字符串的偏移地址是 DS: DX
          
              - 注意
          
                  - 被显示的字符串必须要以 $ 符号结尾( 汇编默认的字符串结尾符号 )。
                  - 所显示的内容不应出现非可见的ASCII码
                  - 回车符和换行符自行添加
          
              - 程序例
          
                  ```
                  DATA SEGMENT
                  	MESS1 DB 'INPUT STRING:', ODH, OAH, '$'
                  DATA ENDS
                  CODE SEGMENT
                     ...
                  MOV AH, 09H
                  MOV DX OFFSET MESS1
                  INT 21H
                  ```
          
          - 返回操作系统 (DOS) 功能
          
              - 功能号 4CH
          
              - 调用格式
          
                  ```
                  MOV AH, 4CH
                  INT 21H
                  ```
  
- ## 半导体存储器

  - #### 半导体存储器基本概念

    - **<font color="red">半导体存储器</font>**由能够表示二进制数 "0" 和 "1"的，具有记忆功能的半导体器件组成
    - 能存放一位二进制数的半导体器件称为一个 **<font color="red">存储元</font>**
    - 若干存储元构成一个 **<font color="red">存储单元</font>** , 内存一个字节由 8个二进制表示，所以一个存储单元由 8个存储元构成
    - 分类
      - 随机存取存储器(Random Access Memory，RAM)
        - 特点：想读就读，想写就写。如果掉电，信息会消失。
        
        - 预备知识
        
          - 8088总线信号
            - 在前面的学习中，都是从cpu的角度看外面，所以关注的信号都是cpu所发出信号。现从存储器的角度看与cpu的通信，便只用关注总线所传递出来的信号。8088总线会将cpu所传递的信号( RD, WR, IO/M 等) 转化 ( MEMR, MEMW, IOR, IOW, 地址信号：访问接口的时候地址信号是 15 位，访问内存地址信号是 19 位的 ) 
            - RD 表示读信号
            - WR 表示写信号
            - IO/M 表示是访问内存还是接口
            - 通过 IO/M 的高低电平以及输出的是 RD 还是 WR，总线会分别将该信号转化为 MEMR (读内存),  MEMW (写内存),  IOR (读接口),  IOW (写接口)。 
        
        - 分类
          - 静态存储器 (SRAM)
            
            - 存储元由双稳态电路构成，存储状态稳定，速度快。但是价格比较贵。由于其稳定性，其外围不需要有复杂的控制电路。综合其价格，现在并没有使用其作为主内存，主要使用其作为 **高速缓存存储器**。速度快，价格高。
            
            - 使用芯片 6264 来说明 SRAM
            
              - 容量 8K * 8b
            
              - 主要引脚
            
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191008_1.png)
            
                - 地址线(adress) A0~A12, 因为有8K个地址，而2的13次方为8K，所以地址信号是13位
                - 数据线(data) D0~D7, 因为每个单元是8位二进制码，所以数据线是8个信号
                - 输出(读)允许信号：#OE，#表示低电平有效
                - 写允许信号：#WE
                - 片选信号： #CS1， CS2，只有当 CS1为低电平， CS2为高电平该芯片才被选中，才会工作。
            
              - 芯片与系统的连接
            
                - 确定要访问的存储芯片：系统中可能存在多片存储器芯片，要访问的单元只能存在于某一片芯片上，也就是说，一个存储单元不可能同时存在于两片存储芯片上
                - 找到芯片后，寻找该芯片上要访问的单元
                  - 6264芯片上有8K个单元，每个单元在该芯片上有唯一的13位地址码
                  
                  - 每片6264芯片上第一个存储单元在该芯片上的地址是： 0
                  
                  - 每片6264芯片上最好一个存储单元在该芯片上的地址是： 8191
                  
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191009_1.png)
                  
            
          - 动态存储器 (DRAM)
            
            - 存储元是由电容构成。电容的特点是只要有电存在，就会发生泄漏，所以为了保证其状态稳定，如果电容的状态是满电状态，必须定时充充电，空电状态必须定时放放电。所以其外围必须要有复杂的控制电路。速度低，价格便宜。
            - 特点：需要定时刷新，定时对存储元进行读或写操作(电容充电、放电)，定时的频率很高，是微秒级别的。现今的主内存主要是由DRAM构造的。
          
        - 存储单元的编址
        
          - 存储单元的地址是由 **片选地址** + **片内地址** 组成
          - 片选地址： 存储单元是存储器中一块区域，存储器由很多这样一块一块区域组成。在cpu访问存储器的时候，需要先确定是那一块区域，而这里我们称这块区域为一片区域，所以该地址的编号称为片选地址
          - 片内地址： 片内地址就是指要访问某一个内存地址相对于其所在的区域的编号。
          - 激活某片区域：每片区域都有一个 CS 信号，称其为片选信号，当其为低电平时( 采用低电平是因为很多干扰信号都是高峰脉冲，所以低电平相对更加稳定和可信 )，表示该片区域被选中。
        
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190927_1.png)
          
        - 译码电路
        
          - 从上面激活某片区域可以看出，当译码电路输出是 00时，选中第一块芯片，01时选中第二块芯片，10选中第三块芯片。所以可以看出译码电路的作用。
          
          - 作用：将输入的一组高位地址信号通过变换，产生一个有效的输出信号，用于选中某一个存储器芯片，从而确定了该存储器芯片在内存中的地址范围。也就是将二进制的输入转化成某个信号输出。
          
          - 译码方式
          
            - 全地址译码：用全部的高位地址(片选地址)信号作为译码信号，使得存储器芯片的每一个单元都占据一个唯一的内存地址
          
              - 因为使用的是全部的高位地址作为译码信号，所以使得存储器芯片上的每一个内存单元都有唯一的一个地址，所以不会浪费地址资源。适合于内存系统设计，因为内存系统的地址资源是很珍贵的。但是对比于部分地址译码来说，其所需要的电路设计会复杂很多。所以，相对应在电路板上所需要的空间就会多很多。
          
              - 示例
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191009_2.png)
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191009_3.png)
          
                看上例，首先，对于一个存储器单元的地址编码包括 **片选地址(高位地址)** + **片内地址(地位地址)**，一个芯片第一个片内地址所有位都是 0， 一个芯片最有一个片内地址所有位都是 1，由此知道芯片的内存地址 3E000H ~ 3FFFFFH，同时这是一个 8K * 8b (8K代表这个芯片的片内地址为13位)的内存芯片， 可以得出高位地址为 0011111；
          
                其译码电路的设计就是通过逻辑计算如与门、非门、与非门等等，由输入 0011111 得到一个确定输入 0。注意这里是全地址译码，所以所有的高位地址必须参与输入，并且任意一位高位地址如果改变值，都会使得最终的输入变为1。也就是处理该输入为0，其他任意的输入通过译码电路都会输出 1。
          
            - 部分地址译码：用部分的高位地址(片选地址)信号作为译码信号，使得被选中存储器芯片占有几组不同的地址范围
          
              - 与全部地址译码不同，部分地址译码只选择部分高位地址作为译码电路的输入，这样可能使得一个芯片同时占据几个片选地址。适合于电路空间狭小的情况，如接口系统等。
          
              - 示例
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191009_4.png)
          
                由上例可以看出，该片芯片的采用部分地址译码，同时译码电路的输入没有 A18这位地址，于是该芯片占据着两个高位地址 1011000, 1111000; 由此会浪费一个地址资源。
            
          - 74LS138 译码器
          
            - 该译码器是一个被封装好的电路，通过特定的输入可以输出特定的输出，就和编程中的函数一样。并且他是一个3输入8输出的专用译码器。也就是说可以同时连接8个芯片来做不同的选择，**并且任意时刻有且仅会有一个芯片被选中**。
          
            - 组成
          
              - 使能端，只用使能端是特定的值的时候，才会用输出值
          
              - 输入端，接受3个值的输入
          
              - 输出端，输出选中哪个芯片的值
          
              - 真值表
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191017_1.png)
      - 只读存储器(Ready Only Memory，ROM)
      - 特点：只读，不需要供电。
        - 分类
        - 掩膜ROM
          
            - 真正的只读存储器，使用光刻将信息写入存储器中，信息永远不可被改变，其状态是十分稳定的。现在已经不用于作为存储器芯片。
        - 一次性可写ROM
            - 真正的只读存储器，使用光刻将信息写入存储器中，信息永远不可被改变，其状态是十分稳定的。现在已经不用于作为存储器芯片。
            
          - EPROM
            
            - 可读写只读存储器，目前用于作为存储器芯片。虽然可读写，但是写是需要具备一定条件的。
            
            - 特点
            
              - 可多次编程写入(所有可读写ROM的特点)
              - 掉电后内容不丢失(所有ROM的特点)
              - 内容的擦除需要紫外线的照射
            
            - 写入顺序：擦除 --> 写入；对于ROM来说要进行写入必须先进行擦除工作。而EPROM在擦除的过程中只能整片擦除，由于是由紫外线进行擦除的，所以其芯片上有一个小窗口，擦除的时候通过该小窗口照射 20多分钟即可，擦除完全所有单元里的内容都是 FF。同时，EPROM 的写入是需要在一个特定的编程环境里面的，其写入的过程是一个字节一个字节的写入，，每个字节写入的间隔是 50微秒，所以，写入 8K个字节需要10多分钟，效率是很低下的。
            
            - 使用场景： 如果该芯片上面的小窗口关闭，其照射不到光线，保存在该芯片上的内容是十分稳定的。所以常用作程序存储器，存放相应的控制程序。而数据因为其总是会变动，所以通常存储在RAM芯片中，以便于操作。
            
            - 芯片示例：EPROM 2764
            
              - 参数
            
                - 8K * 8bit 芯片
                - 地址信号 A0 ~ A12
                - 数据信号 D0 ~ D7
                - 输出信号 OE（低电平有效）
                - 片选信号 CE（低电平有效）
                - 编程脉冲输入 PGM（低电平有效），不可在线写入，同时只有在 PGM 为低电平的时候可以写入
            
              - 与系统的连接
            
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191010_1.png) 
            
          - EEPROM
            
            - 可读写只读存储器，目前用于作为存储器芯片。虽然可读写，但是写是需要具备一定条件的。
            - 特点
              - 可在线编程写入
              - 掉电后内容不丢失(所有ROM的特点)
              - 电可擦除
            - 工作方式
              - 程序写入，可一个字节一个字节的写入，也可一页一页(1～32字节)的写入；
              - 擦除，可一个字节一个字节擦除，也可整片擦除
            - 参数
              - 8K * 8bit 芯片
              - 地址信号 A0 ~ A12
              - 数据信号 D0 ~ D7
              - 输出信号 OE（低电平有效）
              - 写允许信号 WE（低电平有效） 
              - 片选信号 CE（低电平有效）
              - 状态输出端 (READY / BUSY; READY 低电平有效)，状态输出端和系统的连接是通过接口连接的，同时只有READY的时候才能进行写操作。 EEPROM每次写入的时间平均为 100微秒，由于写操作由程序控制同时比较复杂，所以开始写后该信号会变成BUSY。此时不能进行下一次的写操作。
            - 写操作的方法
              - 通过芯片的系统参数设定程序开始进行写操作，在芯片购买之初，可以看到参数设定，知道该类芯片写入数据所花费的时间，由于该时间是平均值，工程上一般会添加 20%，根据这个时间去写入数据。比如参数设定写入时间是 100微秒，则在程序设定的时候，每120微秒进行一次写操作。
              - 通过轮询状态输出端的值，也就是是READY还是BUSY还确定是否写。
              - 通过中断，当写入完成后，进行中断来进行下一次的写入操作。
            
          - 闪速存储器Flash
          
            - 如今，flash被应用的很广泛，比如手机内存卡，u盘等等。其本质是EEPROM，但是与EEPROM的区别在于，flash是否可以写不是通过状态输出端(READY/BUSY)信号来确定的，因为信号是通过接口和cpu连接的，所以速度很慢。其是否可读写是通过flash内部的一个状态寄存器的状态，cpu通过cpu总线可以直接读取该值，所以速度可以达到很快。
            - 特点
              - 通过向内部控制寄存器写入命令的方法来控制芯片的工作方式
              - 通过读状态寄存器的值，获取芯片当前工作状态
              - 与SRAM的区别：在进行写入和擦除操作时需要 12V 编程电压
              - 与普通EEPROM的区别
                - 通过读状态寄存器的内容确定是否可继续写入
                - 提高写命令字的方式控制其处于何种工作方式
            - 工作方式
              - 数据读出：读单元内容；读内部状态寄存器内容；读芯片的厂家及器件标记
              - 编程写入：数据写入；写软件保护
              - 擦除：字节擦除；块擦除；片擦除；擦除挂起
    - 半导体存储器的主要技术指标
    - 存储容量
      
        - 存储单元个数 * 每单元的二进制数位数 (从平时的存储容量的角度来说：8G表示8G个字节，也就是8G * 8位，这里默认了每个单元都有8个存储元，但是从半导体存储器的角度，不一定每个存储单元都由8个存储元所组成，所以采用上述的方式来描述容量，比如 1M * 1bit = 1 <font color='red'>Mb</font> ，这种芯片因为一个存储单元里面只有 1 个存储元，对于今天的计算机来说是没有意义的。同时 1M * 8bit =  <font color='red'>1MB</font> 容量的芯片也是 1MB，这样的芯片对于今天的计算机来说才是有意义的，注意这里的 Mb 和 MB，Mb表示的是位， MB表示的8位)；
    - 存取时间
      
        - 实现一次读或者写的时间。
    - 存储周期
        - 连续启动两次独立的存储器操作所需间隔的最小时间
      - 功耗
      - 可靠性
  
  - #### 微机中的存储器系统
  
  - 微型机中的存储器分类
  
    - 内存
        - 主内存
      - 高速缓冲存储器，就是cache
      - 外存
        - 联机外存
        - 脱机外存
  
    - 存储器系统
  
      - 存在的目的：
  
        |          | 内存                | 外存                |
        | -------- | ------------------- | ------------------- |
        | 存储容量 | 小，一般以 G 为单位 | 大，一般以 T 为单位 |
        | 存取时间 | 快                  | 慢                  |
        | 价格     | 贵                  | 便宜                |
        | 材料     | 半导体材料          | 磁性材料，复合材料  |
  
        基于内存和外存的优缺点，希望结合它们以及软件，组合出性价比较高的存储结构，也就是存储器系统。也就是更大，更快，更便宜的存储器系统。
  
      - 分类
  
        - Cache存储器系统
        
            - 组成：由高速缓冲存储器和主内存构成，由硬件负责管理，对程序员透明 (在计算机中，透明是值本来存在事务，从某个角度上看，像不存在一样)。
        
            - 设计目标：提高CPU访问内存的存取速度
        
            - cpu与cache，cpu访问数据的时候，会首先取cache中访问，如果访问到了(命中)就直接拿走，如果访问不到再去内存中访问。
        
            - cache与主内存
        
              cache和主内存的存储结构是一样的，都是一小格一小格为单位的。在一个格子中可以存储若干条命令。cache映射主内存的单位就是一个格子。由于cache的价格比较贵，所以cache的格子数量远远不及主内存的，比例大概是 1 ： 120；
        
            - cache，主内存，cpu交互
              - cpu首先要访问一条指令，由于是第一条指令，之前没有访问过，所以肯定该条指令是去内存寻找的
              - 由于局部性原理，cache会将cpu找到命令的那一个小格的所有命令映射到自己的小格中，如此在接下来的一段时间内，cpu要执行的命令很大概率都会在cache中这个小格子找到。如果在该小格子中找不到，再去内存中寻找，就会把内存中另外一个小格子的内容也映射到cache中，如此循环
              - 如果cache的的格子满了，会有调度算法对cache进行处理。比如把长时间没有访问的cache格子里的内容再映射回主内存，把该位子腾出来。
        
        - 虚拟存储器系统
        
            - 由主内存和部分硬磁盘构成，主要由操作系统管理
            - 主要设计目的：扩大存储容量
        
      - 微机中的存储器
      
        - 片内存储部件
          - 通用寄存器组以指令，数据缓冲栈
        - 内存储部件
          - 高速缓存
          - 主存储器
        - 外存储部件
          - 联机外存储器
          - 脱机外存储器
  
  - #### 存储器接口设计（存储器扩展技术）
  
    - 存储器扩展技术： 用已有的存储器芯片构造一个需要的存储空间，比如4G内存电脑再插上一个4G内存内存条，就变成了8G内存电脑
    - 特点
      - 用多片存储芯片构成一个需要的内存空间
      - 各存储器芯片在整个内存中占据 **不同** 的地址范围
      - 任一时刻仅有一片(或一组)芯片被选中
    - 存储器扩展方法: 由于存储器芯片的存储容量等与 单元数 * 每单元的位数，所以扩展可分下述三种
      - 位扩展
        
        - 构成内存的存储器芯片的字长小于内存单元要求的字长时，需进行位扩展。扩展每单元的位数。
        
        - 位扩展例
        
          - 实例芯片： DRAM 2164A
        
          - 容量 64K * 1bit
        
          - 采用行地址和列地址来确定一个单元，行列地址分时传送，共用一组地址信号线
        
            ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191014_2.png)
        
        - 位扩展结构图
        
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191014_1.png)
        
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191014_3.png)
        
          将每片的地址线、控制线并联，数据线分别引出
        
        - 注意： **位扩展需要确保所有芯片具有完全相同的地址范围；对需要位扩展的存储芯片，单独1片没有意义**
        
      - 字扩展
      
        - 地址空间的扩展：比如买了一个4G内存的电脑，再买一个4G的内存条插上，使得内存变为8G；此为字扩展。
      
        - 注意： **确保所有芯片具有完全不同的地址范围**
      
        - 扩展原则
      
          - 每个芯片的地址线、数据线、控制线并联
          - 片选端分别引出，以使得每个芯片有不同的地址范围
      
        - 示意图
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191014_4.png)
          
        - 字扩展例
      
          - 题目： 用SRAM 6264 芯片构成容量为 32KB 的存储器，地址范围为 20000H ～ 27FFFH
      
          - 分析：
      
            - SRAM 的容量是 8K * 8b， 所以 32KB 的存储器需要 4 片 SRAM芯片。 20000H 转成二进制为 0010 0000 0000 0000 0000，27FFFFH 转成二进制为 0010 0111 1111 1111 1111； 而 SRAM 是 8K * 8b的芯片，由于是 8K 即为 2的13次方，所以，片内地址为低 13 位，而剩下的7位即位片选地址。可以看出高 7 位中。最后两位不同，所以有四种不同的片选地址(0010 000, 0010 001, 0010 010, 0010 011)，刚好对应 4 个芯片。
      
            - 所以使用 74LS138来作为译码器。
      
              ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191017_2.png)
      
      - 字位扩展  
      
        - 首先进行位扩展
      
          - 用N片芯片构成存储体
          - 利用 A0～A14殉职存储体内32K个单元
          - 所有控制信号线和地址信号线并联引出
      
        - 在进行字扩展
      
          - 利用存储体构成存储器
          - 寻址存储器
      
        - 例
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191018_1.png)
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191018_2.png)
  
  
  
  
  -  ### 输入输出与中断技术
  
    - ##### I / O 接口
  
      - 接口要解决的问题
  
        - 速度匹配问题：数据的缓冲和暂存；由于外设的速度与cpu的速度差别很大，要使得两个部件可以相互交互，需要通过接口来解决。
        - 信号的驱动能力：信号驱动；cpu的能力有限，不可能把计算机的方方面面都管理到，所以在外设方面，需要接口进行辅助
        - 信号形式和电平的匹配：信号类型转换；外设的形式有很多，它们制作的时候有可能标准不一致，会导致cpu和外设的电平和信号形式不一样，因此需要接口进行信号转换
        - 信息格式： 信号格式转换
        - 时许匹配(定时关系)
        - 总线隔离：三态门
  
      - 接口的基本构成
  
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191018_3.png)
  
        输入输出寄存器就是存放即将输入或者输出的数据，在接口中也叫端口；状态寄存器保存外设当前状态供cpu读取，比如打印机，在打印的过程中，会把计算机发送过来的文档存放进一个地方暂存，当存放数据的地方满了之后，外设会改变状态寄存器中的值以供计算机得知打印机目前的情况；
  
      - I/O端口及其编址
      
        - 端口：就是接口存放数据或者控制信息的地方；计算机系统中包含各类不同功能的接口电路，一个接口可以有一个或者多个端口。
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191021_2.png)
      
          - 分类
      
            - 数据端口
      
            - 状态端口
      
            - 控制端口
      
              ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191021_1.png)
      
               
      
          - 编址
      
            - 由于计算机系统中存在多个接口，所以也就存在多个端口，接口也可以看成是一个芯片，因此访问端口就需要其地址；这样端口的地址就和内存地址编码很像了；
            - 寻址方法
              - 先找到端口所在的接口电路芯片 --> 片选地址
              - 再在该芯片上找具体访问的端口 --> 片内寻址
            - 8086/8088 端口寻址能领： 64K个端口
              - 编址方式
                - 与内存统一编址,：简单，控制能力强，会导致内存地址减少
                
                - 独立编址：使用的地址编码与访问内存的地址编码一致，通过 IO/#M 信号来判断是否访问端口。
                
                  - 访问端口的地址总线： A0 ~ A15; 访问端口只需要16位地址码，因为端口只有64K个，地址范围： 0～FFFFH
                
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_1.png)
                
              - I/O 地址译码
              
                - 目的： 确定端口地址
                - 参加译码的信号： #IOR, #IOW，高位地址信号
                - 对端口读/写信号的产生条件
                  - `IO/#M =1`
                  - `#RD = 0` --> `#IOR = 0`
                  - `#WR = 0` --> `#IOW = 0`
                - 高位地址与片选地址
                  - 当接口只有一个端口的时候，全部地址信号皆为高位地址，可全部参与译码，译码输出直接选择该端口
                  - 当接口有多个端口的时候，高位地址参与译码决定接口的基地址，而地位则用于确定要访问哪一个端口 
                - **由于端口地址资源丰富，端口地址译码常采用部分地址译码**
                - 地址译码例
                  - ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_2.png)
                  - ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_3.png)
            
          - 简单接口芯片
          
            - 接口的分类和特点
          
              - 按传输信息的方向分类
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_4.png)
          
                - **输入接口**：信息传输方向由外设走向cpu，这个时候会经历通道3和通道4，通道3是专属于外设的一个通道，是自己的，随便怎么走都可以，也就是说速度的快慢不重要。而通道4是公共的通道，称为系统总线，这个时候传输的速度必须要快，不能慢慢来从而导致抢占公共资源。所以，输入接口要求对数据有控制能力
          
                  - 实现控制能力：三态门
          
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_5.png)
          
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_6.png)
          
                    上述是三态门的示意图，数据从x传向y方向；c端是控制端；当c端处于有效状态的时候，数据直接从x端传递到y端，没有任何可以停留的地方；当c端处于无效状态的时候，x端和y端互不影响，完全cut掉。
          
                  - 74LS244 三态门
          
                    - ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191022_7.png)
          
                      由上面可以看出来，这是左右两端的三态门的c端是分别串连起来，连在输入端 1，和输入端 19；左侧 4 个三态门与输入端1相连，当1处于高电平时，四个三态门被接通。右侧同理。
          
                - **输出接口**：信息传输方向由cpu走向外设，这个时候会经历通道1和通道2；cpu将数据传送的I/O接口速度是很快的，而I/O接口到外设的传输是很慢的，所以就要输出接口必须有对数据存储能力。
          
                  - 实现存储能力：锁存器
              
                - 关于对数据的控制能力和存储能力
          
                  - 控制能力就是我想让数据走就走，停就停。也就是必须有一个开关来掌握着数据的走向
                  - 存储能力就是可以记住数据并且在一段时间内不丢失数据。
          
              - 按传输信息的类型分类
          
                - 数字接口
                - 模拟接口
              
              - 按传输信息的方式分类
              
                - 并行接口：并行接口也就很多数据并排传输，比如同时输送64位的数据；所以，理论上来说他的运行速度是很快的。但是由于是并排传输，也要付出一些代价：比如同时传送64位和只传送1位，所耗费的能源是不一样的；而且由于是并排传输，相互之间会存在干扰现象，在并行接口中会耗费大量的精力去做抗干扰处理。
                - 串行接口：串行接口就是每次只传输单位数据，如此效率相对低下，但是其相互干扰就会小的多，所以很适合长距离运输。同时由于现在的科技发展，在串行接口的效率上会提升很多，什么2倍速啦等等，因为其干扰小，所以传输的频率可以密集一些；现在的u盘之类的都是采用串行接口。
            
          - 基本输入输出方法
          
            - 无条件传送
          
              - 由程序控制，速度不会太快
              - 要求：外设总是处于准备好的状态
              - 优点：软件以及接口硬件简单
              - 缺点：只适合于简单外设，适应范围较窄
              - 例：比如开关，二极管；只有两种状态，没有任何二异性；只需要控制开关即可。
          
            - 查询式传送
          
              - 由程序控制，速度也不会太快
          
              - 要求：设置一些条件，仅仅当达到条件之后才能进行数据传送，**每满足一次条件只能进行一次数据传送**
          
              - 使用场合
          
                - 外设并不是总是准备好
                - 对传送速率和效率要求不高
          
              - 工作条件
          
                - 外设应提供设备状态信息
                - 接口应具备状态端口
          
              - 工作流程图
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191023_1.png)
          
              - 工作方式
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191023_2.png)
          
                其实就是轮询的方式；就是cpu按顺序一个一个的人去问每个外设的设备，如果当cpu问到的时候没有准备好，并且问过之后就准备好了，也只能等到cpu问完一圈，再问道自己的时候才能开始工作。
          
            - 中断方式传送
          
              - 外设在需要时向cpu提出请求，cpu再去为它服务。服务结束后或在外设不需要时，cpu可以执行自己的程序
              - 优点：cpu效率高，实时性好，速度快
              - 缺点：程序编制相对较为复杂，有软件介入，速度不会太快
          
              中断方式就相当于 javascript 中事件的响应机制，当有事件被抛出的时候就去执行这件事情，没有的话cpu该干嘛干嘛。
          
            - 直接存储器存取 ( DMA )
          
              ​	DMA就是在外设和内存中设置一个控制器，相当于一个副手一样帮助cpu来处理内存和外设之间的信息交互。
              
              ​	![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191024_3.png)
              
              - 特点: 
              
                - 外设直接与存储器进行数据交换， cpu不再担当数据传输的中介者
                - 总线由DMA控制器DMAC进行控制，cpu要放弃总线控制权，内存/外设的地址和读写控制信号均由DMAC提供
              
              - 控制方式
              
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191024_1.png)
              
                - 首先外设向DMA控制器发出DMA传送请求，信号DRQ；
                - DMA控制器收到请求后，向cpu发出“总线请求”请求，信号HOLD;
                - CPU在完成当前总线周期后会立即发出 信号HLDA， 对 信号HOLD进行响应
                - DMA控制器收到 信号HLDA后，就开始控制总线，并向外设发出响应 信号 DACK；
              
              - 工作方式
              
                - 周期窃取
              
                  - 以周期为单位，每个DMA周期都只传送一个字节或者一个字就立刻释放总线控制权
              
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191024_2.png)
              
                - 数据块传送
              
                  - DMA控制器在申请到总线控制权后，只有在传送一个数据块后才释放总线控制权，不管在传送过程中 信号DREQ是否有效
              
                - 直接存取方式
              
                  - DMA的数据传送请求直接发到主存储器，在得到响应后，整个工作过程都在DMA控制器中，由硬件完成。
              
            - 四种方式总结
            
              - 无条件传送，中断方式，查询方式都是基于cpu通过执行程序来控制的，同时，I/Oj接口和存储器的读写控制信号、地址信号都是由cpu发出的，一定程度上增加了cpu的负担，限定了传送的最大速度。
              - 无条件传送：简单，使用范围小，仅适用于“随时准备好”的低速外设
              - 查询方式：简单，适用于具备 “状态信息” 的低速外设，同时cpu效率低，控制实时性差
              - 中断方式：适用于中速外设，cpu效率较高，控制实时性较好
              - DMA方式：数据传输有DMA硬件来控制，数据直接在内存和外设之间交换，可以达到很高的传输速率，但控制复杂，硬件成本相对较高
          
        - #### 中断方式
        
          - 中断的基本概念
        
            当cpu正在执行程序时，由于发生了某个 **随机** 事件(中断源)，导致cpu不得不停下当前执行的程序，转而去执行另一段 针对该随机事件的程序( 一段特殊的服务程序：中断服务处理子程序)，并且在执行完这段特定的程序后，恢复到被中断的程序中，继续执行。
        
          - 引入中断的原因
        
            由于查询的输入输出方式会导致实时性低，同时加重cpu负载，所以引入中断。从而可以 **提高对外设请求的响应实时性**，以及 **提高cpu的利用率**，也就是避免cpu不断的去询问外设状态
        
          - 中断类型
        
            - 内部中断
              - 异常中断：由异常事件引起的，比如除法计算中得到的商太大，导致溢出
              - 软件中断：由中断指令控制
            - 外部中断
              - 可屏蔽中断：INTR 中断，在cpu执行的程序的时候，收到中断请求，如果该中断请求优先级没有当前程序级别高，则先执行完当前程序，在进行中断。
              - 非屏蔽中断：NMI 中断，接到指令立刻进行中断，比如断电。
        
          - 外部可屏蔽中断响应的一般过程
        
            - 中断请求
        
              - 对于外部可屏蔽中断请求( INTR )来说：由于中断信号是高脉冲信号，所以要求其不可以太宽也不可以太窄。因为太宽的话，如果cpu处理完中断时，发现其还是高电平，就会再去处理一次中断，如果太窄，中断优先级不够的情况下，等cpu处理完当前程序再去检查中断信号，发现其已经不是高脉冲了，则不进行中断处理。总结来说表述为：
                - 中断请求信号应保持到中断被处理为止
                - cpu响应中断后，中断请求信号应及时撤销
        
            - 中断源识别以及中断判优
        
              - 中断源识别
        
                - 软件查询法：对于中断请求先都进行响应，待可以进行中断时候的，再一个一个询问中断源。效率比较低下。
                - 中断矢量法：类似于人类社会一样，每个中断源都会有特定型号( 人类社会中的身份证 )，cpu根据该型号来确定中断源，该过程由硬件来完成
        
              - 中断判优
        
                - 中断控制器判优 
        
                  ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191025_1.png)
        
                  可屏蔽中断请求连接8个中断源，根据输入的端口，默认优先级最高的是0，最低是7；当然，中断控制器是由程序编写的，所有，这里的优先可以改变。由此比较灵活。谁的优先级更高谁先来。
        
                - 链式判优
        
                  一个链式的结构，一个中断源挂着一个中断源，所以是先到先处理中断源，不可能根据优先级来处理。
        
            - 中断响应：该响应是指具体的响应，其中断响应信号为 `#INTA`
        
              - 当收到可屏蔽中断请求的时候，cpu发出 `#INTA` 信号给中断控制器，表示它已经收到中断请求，至于具体中断请求是哪个中断源，还需要中断控制器来决定。中断控制器收到该请求后，选择优先的中断源，并且向cpu发出中断码
          - 中断响应的步骤( 一下都是由硬件系统完成)
                - cpu向中断源发出 `#INTA` 中断响应信号
              - 关闭中断；再接收到中断请求后，不允许再响应其他中断请求
                - 保护硬件现场；由于中断是去执行另外一段程序代码，执行完后还得回来继续干之前没有被打断的事情，所以，就需要保护现场；也就是将 FLAGS 压入堆栈。
              - 保护断点；将 CS，IP压入堆栈
                - 获得中断服务程序入口地址
            
            - 中断处理（服务）
            
              - 执行中断子程序 (子程序的特点为远程序；所以必须由 `IRET` 指令返回 )；其他具体要完成的事情为
                - 保护软件现场 (各种参数)
                - 开中断 (使用 `STI`命令改变某个状态位的值)；当开始执行子程序后，允许响应其他中断请求
                - 中断处理
                - 关中断 (使用 `CLI`)
                - 恢复现场
            
            - 中断返回：使用 `IRET` 指令，使 IP，CS 和 FLAGS 从堆栈弹出( 恢复现场和硬件现场 )
            
            - 总过程
            
              ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191029_1.png)
            
          - 中断向量表
          
            - 用于存放各类中断的中断服务程序的入口地址
          
            - 位于内存的 00000H ～ 003FFH；其他可以管理 1K 大小的地址。同时一个中断源入口地址占 4btyes 空间 ( 低字为段内偏移，高字为段基址 )，所以，可以存储256个中断子程序入口。
          
              ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191029_2.png)
          
            - 8088 内部中断与 NMI中断
          
              - 特点
          
                - 无 INTA 周期
                - 中断类型码固定或由指令给出
          
              - 组成
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191029_3.png)
          
              - 流程
          
                ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20191029_4.png)
          
          
          
          
  
  