# 微型计算机系统

## 目录

1. [微型计算机是什么](note.md#微型计算机是什么)
2. [微型计算机的组成](note.md#微型计算机的组成)
3. [微型计算机的工作过程](note.md#微型计算机的工作过程)
4. [冯诺依曼计算机](node.md#冯诺依曼计算机)

- ## 微型计算机是什么

  在平时我们使用的个人计算机等就是微型计算机。

- ## 微型计算机的组成

  微型计算机系统由 **硬件系统** 和 **软件系统** 两个部分组成。计算机和计算机系统不是一样的概念。计算机只是包含计算机硬件。

  - #### 硬件系统

    硬件系统包括 **<font color="yellow">主机系统</font>** 和 **<font color="yellow">外部设备</font>**。  
    
    1. **外部设备** 是指能够和计算机进行信息交换，同时又不能直接和计算机进行信息交换，需要通过第三方进行(简单的说外部设备不能直接和cpu进行交换，必须通过输入输出接口，例如鼠标，打印机等等)。 

    2. **主机系统** 包括：

       1. **<font color="#a890f5">cpu</font>**(微处理器): 运算器，控制器，寄存器
       2. **<font color="#a890f5">存储器</font>**: 内存，外存(联机外存(硬盘，如SATA)，脱机外存(移动硬盘))
  
  关于内存储器

  - 表现形式: 内存储器的物理表现形式是有一个一个的黑块块，这些黑块块就是内存芯片。
   ![storage](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190524_1.png)
  
    内存储器的逻辑表现形式是：他是按照单元组织的，每个单元对应于一个内存地址。每个单元的容量都是一样的，即为1字节(1byte = 8bit)。可以把内存条想象一幢大厦，里面的房间想象成单元，房间的门牌号(唯一的)想象成单元地址(唯一的)，房间可容纳的人想象成单元容量。
  
   - 内存操作：读和写；读操作的过程是一个复制的过程，cpu读取内存中的数据是从内存中把数据复制过来，不会对内存中的数据进行破坏。写操作则是是一个破坏性的操作。
       - 分类
         - 随机存取存储器(RAM)：随电而生，随电而亡
     - 只读存储器(ROM)：u盘，不需要电，写操作由条件
       3. **<font color="#a890f5">输入输出接口</font>**(I/O system): CPU和外部设备通信的桥梁  cpu <------> I/O接口 <--------> 外设
  
   - 存在的理由：由于cpu运行速度很快，但是外设的运行速度很慢。如果让cpu取迁就外设，那电脑就没办法用了，于是就有了输入输出接口来平滑这个速度差。平滑的方式就是像暂存区一样，首先接口是专用的，cpu咵的一声就把数据丢到那里了，外设在自己慢慢的从接口中挪数据。而如果是取数据则是，外设慢慢的把数据放在接口处，放完告诉cpu，cpu又咵一声取走了。这样不会耽误cpu干其他事。
     
       - 主要功能：数据换成寄存；信号电平或类型的转换；实现主机和外设间的运行匹配。
    4. **<font color="#a890f5">总线</font>**
          总线上跑的都是高低电平(也就是0,1)，由于他就像是马路，信息就像是车子，马路就这么宽，而车(信息)有很多，所以总线总是存在着争用。所以总线要有裁判的功能。
  


- ## 微型计算机的工作过程
    无论程序是由什么语言编写，到了计算机去实现的时候，都是转变成了一条一条0,1的指令序列。
    - 计算机的工作过程(外存，内存，cpu)
        - 指令的编写: 在今天，我们所编写的程序要想让电脑(cpu)执行，必须存放在内存中。因为只有内存才可以和cpu进行交换。而编写完的程序一般是放在硬盘中，交给内存的程序都是经过0,1编码转化成一条一条语句，在转交给内存。
        - 计算机执行指令的过程
            - <font color="red">获取指令(核心)</font>
            - <font color="red">指令译码(核心)</font>
            - 获取数据
            - <font color="red">执行指令(核心)</font>
            - 存放结果
        - 指令执行顺序: 顺序，并行;
            - 顺序执行：指令完成一个在进行下一个
            - 并行执行：总线在运送完指令后，不等待指令完成就去运送下一个。
            - 加速比：两种方式的执行时间的比值
            - 为什么会有两种并行的指令执行顺序？原因在于cpu在完成人们需求的过程中分为了上述5步，而获取指令是通过总线来把数据从外存拉到内存进行中，然后再进行指令译码以及执行指令的过程。在这个过程中，如果是顺序的执行顺序，也就是说完成一个指令再执行下一个指令，会导致总线在指令译码以及执行指令的过程中空闲。所以为了提高总线的利用率，就有了并行的执行顺序。
    
- ## 冯诺依曼计算机

    #### 原理：存储程序原理

    #### 计算机的一般工作过程

    参与工作的部件：寄存器( pc， AR， DR...)，存储器，控制器，总线，运算器

    相关部件的解释：

    - pc: (也相当于一个寄存器)里面存储着要运算的程序的第一条指令的地址，他的作用就是指针，指向程序存储的地址。

    - AR: 用来暂存地址的暂存器

    - DR：用来赞成数据的暂存器

    过程：

    pc将指令地址传送给AR，AR通过地址去访问该内存单元的内容，控制器下指令取出该内容，并进行指令译码。根据指令进行动作，如有结果输出则送至输入输出接口。

    

    #### 不足

    1. pc将指令传给AR，证明寄存器之间交互很多，所以对总线要求很高
    2. 由程序控制执行顺序，表示不适合高并发的复杂程序。
    3. 由运算器为核心，运算效率不高



- ## 数值及其转化

  - 二进制，八进制，十六进制转化为十进制

  由每个位乘以该进制的位的序号减一次幂，相加。比如：

  1010B = 0 * 2的<font color = 'red'>0次幂</font> + 1 * 2的的<font color = 'red'>1次幂</font>+ 0 * 2的<font color = 'red'>2次幂</font> + 1 * 2的<font color = 'red'>3次幂</font> = 10

  - 十进制转化为二进制

  用十进制除2取余。小数的话则是乘2取整。

  100.2; 分成 100 以及 0.2；

  100转成二进制为： 

  100 /2 = 50 ……0   

  50 /  2 = 25 ……0

  25 /  2  = 12 ……1

  12  / 2   = 3  ……0

  3   /  2   =  1 ……1

  1  /  2    =  0 ……1

  0.2转成二进制为： 

  0.2 * 2 = 0.4   0

  0.4 * 2 = 0.8   0

  0.8 * 2 = 1.6   1

  0.6 / 2 = 1.2   1

  0.2 * 2 = 0.4   0

  ……

  所以最后结果为110100.00110…..

  - 二进制转化为八进制，十六进制

  二进制中四位表示十六进制一位

  二进制中三位表示八进制一位

- ## 编码

  - 编码就是把一种数据合格转换成另一种数据格式。比如把十进制转成二进制。编码的原因是因为计算机智能识别高低电平也就是0和1，所以为了让计算机认识指令，任何数据格式都要处理成0和1的格式。但0和1对于人却不太友好，所以当我们编程的时候，需要把我熟悉的数据格式转换成计算机熟悉的数据格式。

  - #### 主要的编码格式：

    - 二进制编码：用二进制存储的数据格式

    - BCD编码( Binary Coded Decimal )：使用0和1的数据，但是保留逢10进1的规则。其主要也是给人看的。计算机不可以识别该编码。比如 *0001 1001*表示19(十进制)

      - 要达到这个目标就必须要使用 **4位二进制** 来表示1个BCD 编码。因为 3位二进制码最多只能表示到8；而4位二进制码可以表示到16；所以10以上的二进制码是无效的，即 1010 到 1111 都是无效的。
      - 由于用 **4位二进制码** 表示一个数，根据每位的权值(2的幂)也称该编码位 **8421BCD编码**；
      - **转化**：将BCD编码转化成二进制，需要先转化成十进制。
      - **存储**：
        - 压缩BCD码：因为使用4位二进制来表示一个十进制的数，而计算机一个字节是8位，所以一个字节可以存放两个BCD码。当一个内存单元存放两个BCD码，就称作压缩BCD码
        - 扩展BCD码：一个内存单元存放一个BCD码，高位多出的4位使用0补齐，就称为扩展BCD码。

      

    - ASCII编码

      - 格式：由字母，数字，标点，控制器组成，由8位二进制来表示的编码。一般只使用7位，高位默认为0.
      - 校验：奇偶校验：为了防止在传送中出现错误，在8位二进制的最高位使用 **0**和 **1**来表示有  **偶数**或者 **奇数**个1.即最高位使用 0表示由偶数个1，使用1表示由奇数个1.



 - ## 数的表示和运算

    - #### 按数的表示方法分

       - 定点数
         	- 在内存在存储的时候会带上小数点。
          - 缺点：
            1. 现在的计算机都是64位的，按该方法，内存中存储的数的大小限制较大。如果两个差异特别大的数比如10的30次方和10的-30次方，是没有办法一块进行运算的。
            2. 计算的过程中首先要寻找小数点，对齐进行计算，过程比较复杂。
       - 浮点数
         	- 使用类似于科学计数法的方法，以0.xxx乘以10的n次幂的方法。其中小数点后一位 **必须不为0，小数点前面为0**，其中 **0.xxx表示尾数**，而 **10表示阶基**，最后 **n表示阶级**。该数的表现方式大大提高计算机一个字节可以存储的数的大小。

    - #### 按数的性质分(统称机器数)

       - 无符号数
         	- 所有位上的数都是有意义的数字。比如编码啊等，都是使用无符号数。
          - 运算：
            1. 加法
            2. 减法
            3. 乘法
            4. 除法
          
       - 有符号数
         	
         	- 最高位是符号位。表示数字的正负。比如1或者-1就是使用有符号数。
          
          - 有符号数的表示
       
             - 对于一个正数来说，其原码等于反码等于补码，即 X > 0; X原码 = X反码 = X补码
       
             - 对于一个负数来说，其反码等于原码除符号位取反，补码等于其反码加1；
       
             即  X < 0； X反码 = X原码取反(符号位置不取)
       
             ​				   X补码 = X反码 + 1；
       
             比如: X = 1 111 0000; 其反码是 1 000 1111； 其补码是 1 001 0000；
       
             - 原码
               	    - 原码就是给的数字本身，符号位，正数用0表示，负数用1表示。
       
             - 反码
               	    - 原码(负数)的符号位的数字不变，其余位数取反。 **原码** 和 **反码** 的缺点是基准不唯一，也就是0的表示由两种。同时减肥运算相较于加法运算更加麻烦。
       
             - 补码
               	    - 原码(负数)的反码加1。比如 +0 的原码是 0000 0000， -0的原码是 1000 0000，而它们的补码都是 0000 0000。 这样不但基数统一了，同时可以把减法运算变为加法运算。
       
          - 在计算机中的一个特殊的数字  **1 000 0000**
       
            	    - 他如果是无符号数，则表示为 2 的 7 次方， 即为 128；
             - 如果是有符号数字
               	    - 其原码表示为： -0
               	    - 其反码表示为:   -127
               	    - 其补码表示为:   -128 (这个是规定，因为补码把 +0 和 -0 统一了，所以多了一个位置， 人为的定义其为 -128 )
       
    - #### 计算机的局限性
    
       计算机可以表示的数的范围称为 **表数**；受硬件的影响的关系，不管是以前的8位计算机还是现在的64位计算机，对于数字的表示都是有范围的。如果超出了这个表示的范围，则称为 **溢出**。
    
       - 对于 **溢出** 的判断方法
         - 无符号数：最高位是否进位
           - 比如: 1111 1111 + 0000 0001 = 1 0000 0000 最高位进位，溢出
         - 有符号数：最高位和次高位是否同时有进位，或者同时没有进位。(只指加减)
           - 比如：0111 1111 + 0000 0001 = 1000 0000  次高位向最高位 进1，而最高位没有进位， 溢出。
       - 符号二进制和十进制的转化
         - 有符号数的二进制转化，需要求出真值都再进行转换。如果改数是正值，则原码反码补码皆是真值；如果是负数，需要将反码以及补码转化成原码，在进行转化。

- ## 基本逻辑运算与逻辑门

    - #### 逻辑运算的概念

        逻辑运算就是指对一个或者多个 **陈述句** 的命题进行判断其是否正确的过程。比如

        1. **今天我吃早餐** 为真命题， 

        2. **今天我吃早餐了，早餐吃的是馒头**， 这个命题是两个简单命题构成的复杂命题，判断其是否正确需要两个简单命题同时成立。但是结果只可能是真或者假

    

    - #### 使用逻辑运算的原因

      之所以在计算机中使用逻辑运算，是因为逻辑运算的结果只有只有两个状态，真或者假。其可以简单的对应生活中很多物理上的东西。比如开关的开和关，电压的高电平和低电平。数学上的 0 和 1。

    

    - #### 复杂命题的关系

        如上述第二个命题，多个简单命题可以构成复杂命题，但对于各个命题或者命题与自身之间的关系有三种表示。

        1. 非，对于已经得到的结果取反。比如上述 *例1* 取反即为假。使用符号 **1** 表示。其的状态和开关取反状态一致。
        2. 或，两个命题只要有一个成立即可。比如 **他是美国人或者他是中国人。** 多个命题称为 **或门**，使用符号 **>=1** b表示。其可以想象成并联电路，只要一个接通，就会有电。**因为只要有一个状态是真，其余的命题的结果就对总的结果产生不了影响，所以或门也是短路性质的**
        3. 并。 两个命题需要全部成立。如 *例2*。多个命题称为 **与门** ，使用符号 **&** 表示。其可以想象成串联电路。一个断电，全部没电。**因为只要有一个状态是假，其余的命题的结果就对总的结果产生不了影响，所以与门也是短路性质的**
        
    - #### 复杂逻辑运算
    
        复杂逻辑运算就像在数学运算的复杂运算一样，都是有简单的加减符号(与，或，非逻辑)构成的。用的很频繁的逻辑运算有：
    
        1. 与非门
    
           与非门就是对输入的值进行与操作，最后取反。
    
        2. 或非门
    
           或非门就是对输入的值进行或操作，最后取反。
    
        3. 异或门
    
           异或门表示的状态就是 **相同取0，不同取1**，是有符号 **⊕** 表示。也可以把它记为 **不进位相加**。比如
    
           A = 1011 0111 
    
           B = 0100 1001
    
           A ⊕ B = 1111 1110，A，B最后两个1相加等于2，应该进位，但是忽略进位，如此如果没有进位，直接按正常的运法法则计算即可。
    
        4. 同或门
    
           异或门的结果取反。

- ## 章节小结

  考虑下述问题是否清楚的知道。

  1. 微处理器，微型计算机，微型计算机系统三者有什么区别
  2. 计算机为什么要采用二进制，除了二进制还有什么其他的计算制
  3. 什么是有符号数，什么是无符号数
  4. 为什么要引入补码
  5. 冯诺伊曼计算机具有什么结构特点和基本工作原理
  6. 利用冯诺伊曼计算机执行一条指令的过程
  7. 什么是逻辑，真值表的含义
  8. 程序计数器PC的作用
  9. 不同计数制之间如何转换
  10. 原码，反码，补码之间的关系
  11. 二进制的运算
  12. 如何判断运算结果是否溢出
  13. 基本逻辑门电路的符号及输入与输出的关系
  14. 内存的组织模式
  15. **练习**：补码数 **A8H** 对应的十进制数是多少(注意：对于一个正数来说，原码=反码=补码；而对于负数则不是)；



- ## 8088/8086CPU

  - #### 为什么是8088/8086，它们的区别

    **8086芯片** 是第三代芯片，他的总线宽度为16位的，无论数对外或者对内，之前的芯片处理数据的能力是8位的。同时在8088/8086时代，该芯片也具备了并行流水的雏形，中断技术等等。更重要的是，如今的芯片和 **8086** 在重要的部分运行原理是一样的，都是使用冯诺伊曼体系。

    而 **8088与8086** 基本一致，只是对外，**8088** 为了兼容以前的软件等，采用的是8位总线。由于采用的是8位的总线，所以在引脚的一些地方是不同的。除此之外，**8088** 对内也是采用16位的总线，同时 **8088和8086** 使用的指令集是完全一致的。

  - #### 8088/8086相对于第二代芯片的特点

    - 采用了并行流水技术

      通过采用指令预取队列来完成，属于cpu内部结构的变化

    - 实现内存分段管理

      前面提及，内存是直接和cpu进行交互的，内存也被划分成一个一个具有相同存储字长的小格子。这些小格子具有固定的地址，cpu通过拿到某个小格子的地址，去找到这个小格子，获取里面的信息。

      而对于16位的处理器，其最多能表示2的16次方的地址也就是 64 k的地址，如果以这个标准，内存的容量就太小了。所以需要采取内存分段管理来达到内存地址由16位可以表达 1M ( 也就是 2 的 20 次方 )的内存。

      具体方法就是，将内存设置位4个段，并且设置内存寄存器。也就是实地址模式下的寻址。

    - 支持协处理器

      协处理器在今天已经看不见了，因为它已经集成到cpu里面去了。

      协处理器主要是用于浮点数的计算。因为以前都是定点计算，并不支持浮点运算，而定点计算的效率会低于浮点计算。

  - #### 8088/8086的工作模式

    因为支持协处理器，所以 8088/8086 支持两种工作模式： 最大工作模式，最小工作模式。

    - 最小工作模式
  
      只有主cpu在工作。由于控制信息都由主cpu完成，只有一个cpu工作，所以称为最小工作模式。其运行示意图如下：
  
      ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190617_1.png)
  
      因为8088对内存进行一次操作，首先是要知道要操作的内存信息的地址，其次是发出控制指令，在然后就是读取信息。所以8088发出内存信息地址，这时候，由于总线都是共用的，但是内存信息的地址不可以被覆盖，所以有一个ALE指令，将内存地址锁起来。避免其他信息通过产生的电平，将地址信息覆盖。
  
    - 最大工作模式
  
      由主cpu和协cpu一同工作。这个时候，所有的控制信息就不是都有主cpu发出，总线控制器会将一些由总cpu发出的指令分解然后传递出去。也就是总线cpu也担任了一部分产生控制指令的责任。
  
      以下是最大工作模式的工作流程:
  
      ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190617_2.png)
  
      对比于最小工作模式，多了总线控制器和数据收发的交互。
  
    - 判断在那个工作模式
  
      由 MN/MX 表示工作模式，处于哪个工作模式就在工作模式下电平就是个高电平.
      
      
    
  - #### 8088的主要引线及内部结构
  
    之前讲过，cpu完成一次指令的访问需要经过几个步骤
  
    1. 得到由 pc 所指的地址(地址可以在内存中，也可以在I/O接口中)
    2. 发出指令访问该内存地址
    3. 发出指令传输内存地址里面的数据(根据数据类型的不同做处理，如果数据是还是指令，则送去做指令译码等)
  
    由此可以知道，在完成这个过程需要分别对应下述三种信号
  
    1. 地址信号
    2. 控制信号
    3. 数据信号
  
    而8088在内部，总线的宽度为20，也就是有20根并行的总线，由此才能产生1M个不同地址码，管理1M的地址。但是对外8088只有8位宽度，所以遇到要传送16位的数据的时候，需要传送两次。对于20跟总线有以下三种分类：
  
    1. AD0 ～ AD7 表示数据通道(data)，用于传输低8位数据的。但是传输低8位地址信号也是使用它。它们属于分时复用。也就是错开时间使用。所以有上一章所提及的ALE信号来锁住地址信息，避免被数据信号冲掉。
    2. A8 ～ A15 8088处理器专有的地址信号
    3. A16 ～ A19 高4位的地址信号，和状态信号分时复用。<font color="red">这里所说的状态信号是不是就是控制信号呢？？？？</font>
  
    
  
    - 主要的控制信号
      - `#WR`
      - `#RD`
      - `IO/#M`
      - `#DEN`
      - `DT/#R`
      - `ALE`
      - `RESET`
    - READY信号
    - 中断请求和响应信号
      - 中断的意思是
    - 总线保持信号
      - 总线保持是为了
    
    
    
    - #### 8088内部结构
    
      - 8088内部结构分为 **执行单元(EU)**  和 **总线接口单元(BIU)**，如下图(这是示意图，不是原理图)
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190620_1.png)
    
      - 执行单元(EU)
    
        可以看见执行单元主要有4个部分组成
    
        1. 通用寄存器：暂存计算结果
        2. 运算器(ALU,算术逻辑单元)：执行指令
        3. FLAGS，标志寄存器：记录运算器在运算过程中的状态信息(比如有没有进位等)
        4. EU部分控制电路：指令译码
    
      - 总线接口单元(BIU)
    
        用于访问内存或者接口的部件。可以看见主要有以下部分
    
        1. 地址加法器：经过地址加法器从段寄存器中读入地址，在输出生成后的地址
    
        2. 指令队列：使得总线可以在 *EU* 工作的时候预取指令，达到并行工作(并行工作就是指: EU和BIU同时工作)的可能。
    
           对于预取队列，理想的情况是，第一次 EU传递给要取数据的地址， BIU取得数据，放入预取队列中，因为是第一个，所以队列为空，数据直接传递给EU进行指令译码。在EU指令译码，执行指令等过程中，BIU继续去取下一个指令放在预取队列中，EU上一个指令工作结束，马上可以从预取队列中获得下一个指令继续进行工作，从而实现不断流的并行工作。
    
           然而，这只是理想的情况。事实上，可以导致断流的因素有很多，比如
    
           1. 指令取过来，如果该指令需要数据，但数据没有取过来，所以 EU还需等待 BIU把需要的数据取来
           2. 如果取过来的指令是转移类指令，跳转到另外一个指令，则预取的指令依然不能用，需要去取跳转到的指令
    
      - 8088的进步
    
        总的来说：8088提高了运算的速率(有可能并行工作EU和BIU)，降低对存储器运行速度的要求(因为预取队列)
        
        
      
    - #### 8088内部寄存器
    
      1. 通用寄存器(8个)：**只要是通用寄存器就可以用来存放中间运算结果**
    
         - **数据寄存器** 有 4 个，由于8088是内部16位总线，所以处理数据可以达到16位。为了提高数据寄存器的灵活性，这 4 个寄存器分别是由 8 个8位的寄存器组成。比如 AX 由 AH 和 AL 组成； AH 和 AL是两个相互独立的寄存器，它们可以分开单独使用。但是当作为一个寄存器使用的时候，AH代表高 8 位的数据， AL 代表低 8 位的数据
    
           1. **AX** = AH + AL
    
              由于AX的效率相较于其他寄存器来说较高，所以一般用来在 I/O 操作的时候，和接口对接，传送消息。中间运算结果也多半会放在该寄存器中。AX里面的数据没有二义性，只可能是运算结果。
    
           2. **BX** = BH + BL
    
              在寻址的中用于存放基地址
    
           3. **CX** = CH + CL
    
              在循坏操作或者串操作的时候，用于存放计数值，比如说循环操作的时候，循环到第几次的次数就存放在这里面
    
           4. **DX** = DH + DL
    
              在间接寻址的 I/O 指令中存放 I/O 端口地址。在处理32位运算数时， 用于存放高 16位数。
    
         - **地址指针寄存器**
    
           1. **SP** 堆栈指针寄存器，其内容为栈顶的偏移地址，也是在堆栈操作的时候，其存放的地址总是指向栈顶，只要有堆栈操作，其就是专用寄存器 
           2. **BP** 基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址，在堆栈操作中，其可以指向栈中的任意位置
    
           **BX 和 BP 的区别在于 BX是活跃在数据段中；而 BP是活跃在堆栈段**
    
         - **变址寄存器** 变址寄存器在指令中常用于存放数据在内存中的地址
           1. **SI** 源变址寄存器
           2. **DI** 目标变址寄存器
    
      2. 段寄存器(4个) 用于存放逻辑段的段基地址
      
         - **CS** 代码寄存器
         - **DS** 数据寄存器
         - **ES** 附加段寄存器
         - **SS** 堆栈段寄存器
      3. 控制寄存器(2个)
         - **IP** 指令指针，在BI要取指令，会去看IP所指的位置，IP指向哪里就去哪里取？完全取决于程序计数器(IP)的指向的位置。所以 IP 称为指令指针，instruct pointer。
         - **FLAGS** 标志寄存器，用来存储运算结果的特征，比如有没有溢出等等。 只有9位有意义，其他7位是空闲位。
           - 状态标志位(6位):
             - **CF(carry flag)** 进位标志位，最高位有进位或者借位 1，表示无符号数计算溢出
             - **SF(sign flag)** 符号标志位， 运算结果最高位是 1， 为1；
             - **AF(Auxiliary carry flag)** 辅助进位标志位，在加减操作时，若bit3向bit4有进位或者借位，为1；
             - **PF(parity flag)** 奇偶标志位，运算结果的低8位中， 1的个数为偶数时，为1
             - **OF(overflow flag)** 溢出标志位，有溢出则为 1，表示有符号数计算溢出
             - **ZF(zero flag)** 零标志位， 运算结果为0的时候，为 1
           - 控制标志位(3位)
             - **IF(Interrupt Enable Flag)** 中断允许标志位，当其为1时，使CPU可以响应可屏蔽中断请求
             - **TF(Trag Flag)** 陷进标志位，当其为1时，cpu单步执行
             - **DF(Direction Flag)** 方向标志位，在数据串操作时确定操作的方向
      
      
    
    - #### 实模型下的存储器寻址
    
      - 内存储器管理
    
        由于8088时一个16位的芯片，所以无论是他的总线宽度，并行处理数据的位数都是16位的。这意味着，它可能同时管理2的16次方也就是64k个地址。但是64k的个地址实在是太小了。所以，需要有一个办法来提神其管理的容量。
    
        借助大楼的思想，在一层的房间都是以1开头，二层的则是以2开头。可以在内存地址中，在16位的前面加上4位区域地址，就可以管理 1M 内存了。
    
        但是这个管理方法有缺点：
    
        1. 因为cpu是16位的，而如果要使用4位的区域地址，而需要在添加专门的4位的寄存器，总线等等。与原本的cpu的体系格格不入
        2. 这个办法会导致单位内存利用率低下，比如，在一块内存中，如果一块内存被占用了。但是实际上它用不到那么大的内存，这会导致内存的浪费。
        
      - 内存单元的编址
      
        也是把内存分为一个一个的区域，为每个区域编上编号，再在每个区域中定义一块内存在该区域中所占据的位置。每个区域的编号就是段基地址，而在该区域中的位置，采用偏移地址的方式。也就是指定地址距离第一个地址的距离，称为段内地址。
      
        - 段基地址
      
          指存储单元在整个内存空间中处于哪个区域。8088只有4种区域，也就是4种段基地址，分别存在段寄存器中，每个逻辑段中存储单元的数量最多不超过 **64k**个：
      
          1. 代码段 存放指令代码
          2. 数据段 存放操作的数据
          3. 附加段 存放操作的数据
          4. 堆栈段 存放暂时不用但需要保存的数据
      
        - 段内地址
      
          指存储单元在段内的相对地址，也就是距离段内第一个存储单元的偏移量
      
        **无论是段基地址还是段内地址，都是16位的。**
      
        - 段首
      
          段首就是指在一个段中第一个存储单元，由于其相对于自己的偏移量是0，所以段首的段内地址就是0 。
      
        **所以得到的结论就是，一个存储单元的地址 = 该存储单元所在段的段首地址 + 偏移地址**
      
        由于段首地址的偏移量是 0；所以16位0，4位0，1位0都是0。 而对于管理 1M 个内存单元来说， 只需要20位即可。所以在 **内存分段的时候，每个段的段首，都是以节为边界来起始的，也就是说任何一个段的段首地址都要能够被16整除** 的前提下，可以将16位的 0 转写成4位的 0。
      
        - 物理地址
      
          独一无二的内存地址，也就是说，每个内存其实都是有一个独一无二的内存地址的。如果我们的技术可以做都内存中有 1M个内存单元，也就是说有 1M个客观存在真实内存地址。我们要怎么去使用 16位的cpu去管理这 1M的内存单元呢。
      
          基于上述的 **段基地址**， **段内地址**， **段首地址**，就可以由 16位的cpu去管理 20位的地址。
      
          所以物理地址 = 段首地址 + 段内地址(偏移地址)。
        
      - **总结一下**： 在8088中，所使用的内存芯片的大小是 1M，所以每个内存地址最少要用 20位( 2的20次方 )来表示。并且，每个内存单元都对应着 **唯一的，确定的，<font color="red">不变的</font>** *物理地址*。也就是说，在 8088中，如果一个内存地址是20位，那这个地址一定是某一个内存单元的 **<font color="yellow">物理地址</font>**。
      
        而物理地址又是由 **段基地址(16位)** + **段内地址(16位)** 所得。而 **段内地址** 指的是所使用的内存地址距离第一个内存单元( **段首地址**)的偏移量，所以 **段首地址** 就变成找到所使用内存单元的一个重要条件。但是 **段首地址** 也是存放在内存中的，它也有具体的物理地址，而他自己对于自己的偏移量是 **0**； 所以，段首地址就等于 **段基地址向左偏移16位**；由于 **16位的0，也是0，4位的0也是0；1位的0也是0**，而 8088的内存单元的物理地址是 20位的，所以在 **<font color="red">8088中，内存单元的物理地址是由20位组成，而所有20位的地址一定是内存单位的物理地址</font>**
        
        比如在8088中，一个段基地址是 2309H
        
        他的逻辑段首地址是 2309 : 0000 H
        
        他的物理段首地址是 23090H
        
      - 例子
      
        - 设某个数存放在数据段中，段基地址 DS = **250AH** ,数据所在单元的偏移地址是 **0204H** ，数据的物理地址是多少。
      
          **物理地址 = 段首地址 + 偏移地址**
      
          段基地址： 250A0 H (向左移动4位，由16进制表示就是一位，所以在后面加一个 0 )
      
          偏移地址： 0204H
      
          物理地址：250A0 + 0204 = 252A4H
      
        - 已知 **CS=1055H**, **DS=250AH**, **ES=2EF0H**,**SS=8FF0H**，画出各段在内存中的分布(默认每个段的大小是 64K)
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190702_1.png)
      
          
      
      - 由于逻辑地址的是由 **段基地址** 加上 **偏移地址** 组成，这两个地址都是逻辑上的，并且 **段基地址** 是存储在段寄存器中的，这意味着 **段基地址** 是可以变化的，这就使得一个段的位置可以在内存中路灵活的变换。同时，一个内存单元的的地址是由偏移量所决定的，这使得一个段可以和一个段相互交叉，一个内存地址可以分时被两个段所使用。
      
      - #### 逻辑段和逻辑地址
      
        - 内存的分段是逻辑分段，不是物理分段。各个逻辑段在地址上可以不相连，可以部分重合，也可以完成重合。
        - 每个内存单元一定具有 **<font color='red'>唯一的物理地址</font>**，但可以 **<font color="red">多个逻辑地址</font>**
      
      - #### 操作系统和逻辑段
      
        逻辑段之所以是采用 段基地址 + 偏移地址 来表示，这是由于操作系统的原因，我们写好的程序在不使用的时候是放在硬盘中的，在使用程序的时候，操作系统会把程序代码读入到内存中，插入内存的方式是见缝插针式的。所以想要表示出一个内存的地址，就要知道它是什么类型的代码，存放在哪个区域，距离该区域的段首地址的偏移量是多少。
      
        在电脑中，段基地址是由操作系统来控制的。
      
      - #### 堆栈段
      
        - 内存中一个特殊区域，用于存放暂时不用或需要保护的数据
        
        - 常用于响应中断或子程序调用
        
        - 指针
          - 栈顶 SP，SP (地址指针寄存器)指向栈顶的位置
          - 栈底 SS，SS是堆栈寄存器的段基地址
          
        - 例 SS = 1000H，SP= 0100H，求栈顶地址
        
          段首地址为 10000H， 栈顶偏移地址为 0100H， 栈顶地址为 10100H
        
        - 例 SS = 1000H，该段最后一个单元位 10200H。则栈底偏移地址为？
        
          段首地址为 10000 H， 最后一个单元为 10200H， 偏移地址为 10200 - 10000 = 0200 Hs
          
          
      
    - ### 8088系统总线
    
      - #### cpu时序
    
        cpu时序指的是cpu在工作过程中的各个引脚信号在时间的关系。以以下8088的工作时序图为例
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_1.png)
    
        - 在该图中，x轴表示时间，y轴表示各个引脚信号在不同时间的幅值(高低电平)。
        - CLK 表示时钟，就像在 人类社会的时钟一样，计算机在运行的过程中，也需要一个时钟，CLK就是这个时钟
        - A19/S6 - A16/S3 表示 A19 - A16 与 S6 - S3 所分时复用的总线。这里表示的状态是总的如(A19-A16)的状态，并不是单一的某个总线的状态。
        - A15 - A8， AD7 - AD0 同理
        - ALE 表示地址所存信号， 高电平的时候有效， 单有总线输出的是地址信号的时候， ALE为高电平， 表示有效， 将地址信号锁存
        - IOM 表示读取信号的位置是接口还是内存
        - RD表示读信息， 低电平有效，当为低电平的时候，可以进行读操作
        - DT/R 读取方法
        - DEN 片选信息， 有效才能才信息读取进来cpu
    
      - #### 总线周期
    
        cpu访问一次内存或者接口所需要的时间，包括四个阶段，T1,T2,T3,T4。如果在一个周期内有延时则在T3后 main添加TW阶段，可以添加多个TW。
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_2.png)
    
      - #### 总线分类
    
        - 按照传送信息的角度
          - 地址总线
          - 数据总线
          - 控制总线
        - 按照层次分类
          - cpu总线，cpu总线的标准并不统一，所以如果将cpu与接口相连，对于接口的制作不利，所以cpu总想必须要与系统总线相连
          - 系统总线，有统一的标准，现在主要有两种，PEI和PEIC总线。连接cpu和接口
          - 外部总线，连接cpu与外接设备如键盘等
    
      - #### 总线结构
    
        - 单总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_3.png)
    
          单总线的结构的缺点很明显：
    
          1. 接口设备和内存使用统一条总线，为了迁就接口设备，会导致总线上的速度不会太快，从而降低计算机运行效率
          2. 总线上挂着多个设备，导致争用问题很严重
    
        - 双总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_4.png)
    
          将内存和cpu的交互与接口和cpu的交互的总线分开，提高了计算机的运行效率。但是接口与内存的的交互就必须要通过cpu控制，也就是软件进行控制，这样速度同样不会太快。
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_5.png)
    
          在内存和接口也连接一条总线，是的接口和内存可以相互访问。
    
        - 多总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_6.png)
    
      - ####总线功能
    
        - 传输数据
        - 仲裁功能
        - 出错处理
        - 数据驱动
    
      - #### 总线评价指标
    
        - 总线带宽 B/S
    
          单位时间里，总线所传送数据的能力
    
          总线带宽 = 总线宽度(如 8 位) * 工作效率( 传输数据的速度)
      
    
    
    
    - ## 指令系统概述与数据传送指令
    
      - ### 指令系统的基本概念
    
        - #### 指令及指令系统
    
          - 指令：指的是人对计算机发出的指令。
    
          - 指令系统：因为指令是人对计算机发出的，然而人和计算机是不可以直接沟通的，所以计算机可以识别的指令的集合就是该cpu的系统集合
    
          - 指令的兼容性：随着cpu的发展，cpu的指令会有所改变，但是后一代的cpu可以识别上一代的指令，这就是指令的兼容性。
    
          - 指令包含的信息以及格式
    
            - 包含的信息：分析指令的含义可以知道指令要包括： 从哪里来，去哪里，做什么三个部分
    
            - 格式： 操作码 [操作数] [操作数]
    
              这里的操作码就是该指令应该干什么，中括号表示操作数是可选填的。第一个操作数是目标操作数也就是去哪里，它可能代表一个含义也可能代表两个含义，一定代表的是地址，因为计算机每次操作完一个流程，必须要知道操作的结果放在哪里。它也可能同时表示目标地址和操作数。比如 add 5 3，5就表示地址和操作数。第二个操作数可能是数据也可能是地址码
    
            - 分类，无操作数指令和单操作数指令并不是真正的没有操作数，而是因为操作对象是默认的，所以隐藏起来了。
    
              - 无操作数指令
              - 单操作数指令
              - 双操作数追指令
              - 多操作数指令
        
            - 操作数的种类
        
              - 立即数 
        
                立即数就是一个常量，就是一个数字。可以直接被cpu使用。 **<font color='red'>由于立即数只是一个数，没有任何其他的含义，也就是不能表示地址，所以立即数不能作为目标操作数，因为目标操作数必须是一个地址</font>**
            
              - 寄存器地址
            
                在cpu中有专门存放运算中间结果的地方，称为寄存器比如(AX,BX …)；所以它表示一个地址。如果操作数是它，因为在cpu内，所以运算速度比较快。
            
              - 存储器地址
            
                如果操作数使用 `[]`中括号括起来的，就表示存储器地址，也就是操作数被放在了内存中。比如 `MOV AL [1210H]` 就表示把偏移地址为 1210H的单元里面的数字移动至 AL中。**<font color='red'>注意：一般我们都只会操纵存储单元的偏移地址，所以`[ ]`中，是偏移地址。</font>** 如果目标地址是一个16位的存储单元，则cpu会搬运 1210H以及 1211H 存储单元里面的内容。 **<font color='red'>也就是源目标数据的长度由目标操作数决定</font>**。
            
          - #### 寻址方式
        
            - 立即寻址
            
              说白了，就是操作数是立即数，只是以寻址的方式去分类。所以其的注意和立即数一样。
            
              立即寻址就是指操作的对象就是给出的操作数。比如 `MOV AX 1200H`；其中1200H就是一个操作数直接给出的。所以立即寻址一般是和代码一块放在代码段的。
            
              所以立即寻址不可以表示目标操作数。**<font color='red'>所有的寻址方式中，操作数的长度是8位还是16位是由另外一个操作数所决定的</font>**
            
            - 寄存器寻址
            
              指令存放在寄存器中。
            
              **数据通常是放在通用寄存器中的，偶尔会在段寄存器中，绝不会在控制寄存器中**
            
            - 存储器寻址
            
              数据存储在存储器中。需要注意三点
            
              1. 表现形式，由中括号 `[ ]` 包裹
              2. `[ ]`表示偏移地址，这个偏移地址不是真实的偏移地址，因为在编写程序的时候没有办法确定段基地址，只有在程序进行编译的时候，计算机会将计算出真实的偏移地址，由给出的偏移地址加上段基地址组成。
              3. 逻辑段的段基地址地址通过默认或者重设的方式给出
              4. 存储器操作数的字长并不确定。
            
              存储器寻址又包括
            
              1. 直接寻址： 指令中直接给出操作数的偏移地址 `MOV AX [1200H]`;
                 - 操作数位置与段重设：段地址默认是在数据段中的，但是允许段重设比如：MOV AX, ES: [1200H]；
              2. 间接寻址：**数据存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容**。也就是说，偏移地址存放在某一个寄存器中。`MOV AX [BX]`
                 - 间址寄存器：可以用来存放数据的间接地址，只有四个通用寄存器：**BX**, **BP**,**SI**,**DI**;
                 - 操作数的位置与段重设：
                   - 如果偏移地址存放在 **BX**, **SI**, **DI**; 则默认是在数据段中
                   - 如果偏移地址放在 **BP** 中，则默认在堆栈段中
                   - 同样可以通过段重设的方式重设数据存放位置(不包括将数据存放在代码段中)
              
            - 寄存器相对寻址
            
              操作数的偏移地址为寄存器的内容加上一个位移量： MOV AX, [BX+DATA], 也可以写作 MOV AX, DATA[BX], MOV AX [BX]DATA
            
            - 基址、变址寻址
            
              - 操作数的偏移地址： 一个基址寄存器( BX ：默认在数据段, BP ：默认在堆栈段 )的内容 + 一个变址寄存器( DI, SI )的内容；基址寄存器内存储的内容主要是段基地址，变址寄存器中存储的主要是偏移地址
            
              - 用途：**与相对寻址一样，主要是用于一维数组操作**
            
              - 例子: 下述地址表示偏移地址为 2200H，存储在数据段中。
            
                ```js
                MOV SI, 1100H
                MOV BX, SI
                MOV AX, [SI + BX]
                ```
            
            - 基址，变址，相对寻址
            
              - 操作数的偏移地址组成： 一个基址寄存器( BX ：默认在数据段, BP ：默认在堆栈段 )的内容 + 一个变址寄存器( DI, SI )的内容 + 位移量。
              - 用途：主要用于二维数组，表头，行地址，列地址
            
            - 隐含寻址
            
              - 指令中隐含一个或者两个操作数，也就说操作数是默认的。
              
            - 寻址练习
            
              - 设 DS = 6000H, ES = 2000H, SS = 1500H, SI = 00A0H, BX = 0800H, BP = 1200H, 字符常数 VAR 为 0050H。 说明以下各条指令源操作数的寻址方式及存储器操作数的物理地址。
                - `MOV AX, BX` 寄存器寻址, 寄存器操作数不存在物理地址，它只是一个符号而已。
                - `MOV DL, 80H` 立即寻址
                - `MOV AX, VAR[BX][SI]` 基址变址相对寻址，BX,BP存储段基地址，SI, DI存储着偏移地址。 所以偏移地址为。0800 + 00A0 + 0050 = 08F0; 由于有BX存在，所以默认存储在数据段中，所以段基地址为 DS 6000H, 段首地址为 60000H；则物理地址为 608F0 H；
                - `MOV AL 'b'` 立即寻址
                - `MOV DI, ES: [BX]` 段重设，存储器间接寻址。偏移地址 0800H, 段重设后段首地址为 20000H, 物理地址为 20800H 
                - `MOV DX, [BP]` 由于存储地址为 BP, 所以默认放在堆栈区，所以物理地址为 15000 + 1200 = 16200H
                - `MOV BX, 20H[BX] ` 存储器相对寻址,  地址存储在 BX 中，默认在数据段，所以偏移地址为 0800H + 2000H 即 2800H；物理地址为 60000H + 0820H = 60820H
                
                
            
          - ### 通用数据传送指令
          
            - 8086指令集
              - 数据传送
                - 通用数据传送指令(**不影响**标志位）
                  - `MOV dest, src` 双操作数
                    - 要求两个操作数必须等字长
                    
                    - 要求两个操作数不允许同时为存储器操作数
                    
                    - 两个操作数不允许同时为段寄存器( 也就是不允许将一个段寄存器的值赋予给另外一个段寄存器 )
                    
                    - 源操作数是立即数的时候，目标操作数不能是段寄存器( 也就是说段寄存器不允许使用立即寻址的方式赋值 )
                    
                    - IP 和 CS 不作为目标操作数，FLAGS一般也不作为操作数在指令中出现( IP是地址指针, CS是代码寄存器，一般不会作为操作数出现，一定不能作为目标操作数 )
                    
                    - 例子
                      - `MOV AL, BX` 错误，操作数不等字长
                      - `MOV AX, [SI]05H` **正确**
                      - `MOV [BX][BP], BX` **错误**，BX，BP 是存放基址的寄存器， SI，DI存放变址的寄存器。从寻址方式上来说，没有将基址寄存器中的地址赋予给基址寄存器的方式。只有基址变址。 
                      - `MOVE DS, 1000H` **错误**，不可以使用立即寻址的方式给段寄存器( CS，DS，ES，SS)赋值。
                      - `MOV DX, 09H` **正确**
                      - `MOV [1200H], [SI]` 错误，两个操作数同时为存储器操作数
                      
                    - 例子应用
                    
                      - 题目：将 `*` 的ASCII码 2AH 送入内存数据段1000H 开始的 100 个单元中
                    
                      - 解
                    
                        ```
                        MOV DI, 1000H ;SI,DI 为变址寄存器，SI为源变址寄存器，DI为目标变址寄存器
                        MOV CX, 64H
                        MOV AL, 2AH
                        AGAIN: MOV [DI], AL
                        			 INC DI
                        			 DEX CX
                        			 JNZ AGAIN
                        			 HLT
                        ```
                    
                        上述代码经过编译后，代码段以及数据段的情况如下
                    
                        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190729_1.png)
                    
                        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190729_2.png)
                    
                  - 堆栈操作指令
                  
                    - 堆栈操作的原则：先进后出，以字节为单位
                    - 堆栈操作指令`
                      - 压栈 `push OPRD`
                    
                        - 压栈就是先将栈顶指针减2，将操作数的高 8 位压入，再将操作数的第八位压入。此时指针向上移动 2 位。(进行堆栈指令的操作数一定是16位的)
                    
                          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190730_1.png)
                    
                      - 出栈 `pop  OPRD`
                    
                        - 将栈顶指针下移2个单位，依次读出单位里面的数。这个过程仅仅是一个读的过程，所以读出的操作数并不是真正的被删除掉，只是在读的过程中，栈顶指针下移，所以，这两个操作数对于本堆栈来说就是不存在的。
                    
                          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190730_2.png)
                    
                      - 堆栈过程中应该注意的事
                    
                        - 操作数必须是16位的
                        - 操作数的字长必须确定，如果是存储器操作数必须指定字长。寄存器的操作数字长cpu是知道的( 比如 AX 是16位的，AL是8位的)。不能为立即数。( **8086规定所有单操作数的指令，其操作数不可以是立即数** )。(对于压栈指令来说，其操作数是源操作数，对于出栈指令来说，其操作数是目标操作数。目标操作数是不可以使用立即数来表示的，因为立即数没有任何地址的含义)
                        - 不能从栈顶弹出一个字给CS（段寄存器中的代码段）
                        - PUSH和POP指令一般成对出现
                        - PUSH指令的操作方向是从高地址向低地址(因为要把高地址压入下面),POP指令的操作正好相反
                    
                  - 交换指令
                  
                    - 交换两个操作数的位置，从功能上来说，它可以被 MOV 指令或者堆栈指令所替代，但是交换两个操作数，交换指令只需要写一条，而 MOV 指令则需要写 3 条， 堆栈指令则需要写 4 条。
                    - 格式 `XCHG REG, MEM/REG`
                    - 对于操作数的要求，由于是互换两个操作数，所以，这两个操作数即是源操作数也是目标操作数，也就是说，交换指令的操作数不可以是立即数。同时由于两个操作数不能同时是存储器操作数，因为存储器操作数的字长不确定，所以，该指令的操作数有一个必须是寄存器操作数，剩下一个可以是寄存器或者存储器操作数。同时，不允许使用段寄存器。
                  
                  - 查表指令
                  
                    - 用于操作一维数组的指令，可以被 MOV 指令所取代。( 前面讲过，操作一维数组可以使用寄存器相对寻址，基址变址寻址 )
                    - 该指令是零操作数指令，格式 `XLAT`
                    - 该指令默认一下过程
                      - 使用 BX 里面内容作为表头地址
                      - 使用 AL 里面的内容作为偏移地址
                      - 将 BX 和 AL 里面的内容作为地址取出指定单位的内容
                      - 将指定单位的内容送给 AL
                      - 总结就是 BX + AL —> AL
                  
                  - 字位扩展指令
                  
                    - 该指令 **只针对有符号数**，对于无符号数只需要在高位加上足够多的零即可。该指令是用于扩展操作数的位数，比如把8位扩展到16位，把16位扩展到32位。
                    - 字节到字的扩展
                      - 格式 `CBW`
                      - 将 AL 的内容扩展到 AX
                    - 字道双字的扩展
                      - 格式 `CWD`
                      - 将AX内容扩展到 DX AX
                    
                  - 地址传送指令
                  
                    - `LEA` 取偏移地址指令(只是在本段中获取偏移地址，所以忽略段基地址)，取近地址指针。
                  
                      - 操作 将变量本身的16位偏移地址写入到目标寄存器。因为变量表示的是 **内存单元** 的符号地址，所以变量属于存储器操作数。而当程序中如果需要使用变量表示某个内存单元的偏移地址的时候，则需要使用该命令。
                  
                      - 格式 `LEA REG, MEM`, 该命令中，目标操作数是寄存器操作数，源操作数是存储器操作数
                  
                      - 作为寄存器操作数，存放的寄存器不可以是段寄存器，因为里面存放着段基地址。不可以是标志寄存器。原理上来说是要放在 8 个通用寄存器中间。但是，去的偏移地址的目的是 基址变址寻址，所以最好把偏移地址放在4个 间址寄存器(用于存放间接地址的寄存器， SI，DI，BX，BP)中间，这样可以方便后面的操作。
                  
                      - 与 `MOV` 指令的对比
                  
                        - `MOV` 指令获取的是变量所存储的内容，`LEA`获取的是变量本身的偏移地址。举个例子，有一栋房子 `house`，门牌号是 A220，里面放了一把椅子。使用 `MOV AX house` 搬运的是里面的椅子，而使用 `LEA AX house` 搬运的是门牌号 `A220`
                  
                        - 一个例子
                  
                          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190731_1.png)
                  
                        - `LEA`的应用
                  
                          - 题目： 将数据段中首地址为 MEM1 的 50 个字节的数据传送到同一逻辑段首地址为 MEM2 的区域存放。编写相应的程序段。
                  
                          - 解 
                  
                            ```
                            LEA SI, MEM1
                            LEA DI, MEM2
                            MOV CL, 50
                            NEXT: MOV AL, [SI]
                            			MOV [DI], AL
                            			INC SI,
                            			INC DI,
                            			DEC CL,
                            			JNZ NEXT
                            			HTL
                            ```
                  
                            
                  
                    - `LES`获取偏移地址指令，包括段基地址和偏移地址，因为是去别的段取数据，取远地址指针
                  
                      - 格式 `LES 通用寄存器 存储器操作数`
                      - 默认将源操作数的段基地址送到 `ES`, 偏移地址送到指定的通用寄存器
                  
                    - `LDS` 获取偏移地址指令，包括段基地址和偏移地址，因为是去别的段取数据，取远地址指针，与`LES`的不同之处在于，获取段基地址后，默认存储的地方不同。
                  
                      - 格式 `LDS 通用寄存器 存储器操作数`
                      - 默认将源操作数的段基地址送到 `DS`, 偏移地址送到指定的通用寄存器
                  
                  - 标志传送指令
                  
                    - `LAHF` 零操作数指令，将 `FLAGS` 的低八位装入 `AH`
                    - `SAHF` 零操作数指令，将 `AH`装入 `FLAGS` 的低八位
                    - `PUSHF` 零操作数指令，默认源操作数为标志寄存器中的数。压栈操作, 默认的目标操作数是堆栈段
                    - `POPF` 零操作数指令，默认源操作数为标志寄存器中的数。出栈操作, 默认的目标操作数是堆栈段
                  
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190731_2.png)
                  
                  
                  
                - 输入输出指令(**不影响**标志位）
                
                  - I/O端口： 端口实际上就是 cpu 在与外部设备进行交互的时候，存放在接口中的寄存器。与cpu内部的寄存器一样，端口可以直接被cpu所访问。实际上，仅仅是为了区分与cpu内部寄存器的区别，他才会被命名为端口的。 **<font color='red'>I/O接口中，用于存储数据，可以直接被CPU访问的寄存器</font>**。
                
                  - 计算机输入输出系统中可以包含若干接口控制电路(芯片), 每个接口中都包含 1个或 多个 端口。
                
                    ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190801_1.png)
                
                  - 端口的寻址方式: 端口地址在指令中的表现形式
                
                    - 直接寻址，在8086中，当端口地址是 8 位的时候，源地址可以使用立即数表示。
                    - 间接寻址 ，在8086中，当端口地址是 16 位的时候，源地址必须由 DX( DX 不作为 `IN`或者 `OUT`指令的时候大多数是存放运算中间结果的，但是在`IN`或者`OUT`指令中出现的时候，一定是表示端口地址，在8086中，端口地址可以是 64K 个) 指定。
                
                  - 输入输出指令
                
                    - 指令功能： 从端口地址读入数据到累加器(AX或者AL，不包括AH)，或者将累加器的值输出到端口中
                    - `IN` 指令
                      - 格式 `IN acc, PORT` ，acc是个符号，表示累加器 AX / AL
                    - `OUT` 指令
                      - 格式 `IN PORT, acc` ，acc是个符号，表示累加器 AX / AL
                    - 例子
                      -  `IN AX, 80H` 端口地址为 8 位，可以通过立即数给予，寻址地址为 256 个。
                      - `MOV DX, 2400H` 在这个指令中， 2400H 仅仅表示 2400H。
                      - `IN AL, DX` 2400H在DX，DX在 `IN` 指令中，表示 将端口地址为 2400H的端口里的内容移至累加器 AL。
                      - `OUT 35H, AX` 将累加器 AX的内容移至端口地址为 35H的端口里。
                      - `OUT AX, 35H` 格式错误。 `OUT`的目标地址必须是端口地址，所以只能是立即数或者是 DX。
                
              - 算术运算
              
                算术运算指令普遍都会影响状态标志位( CF, AF, ZF, OF, PF, SF )
              
                - 加法运算指令
              
                  - 普通加法指令 `ADD`
              
                    - 会影响 6 个状态标志位
              
                    - 格式： `ADD OPRD1, OPRD2` 即 将 OPRD1 和 OPRD2 的值相加赋予 OPRD1.
              
                    - 例
              
                      ```
                      MOV AL, 78H
                      ADD AL, 99H
                      ;将 78H 与 99H 相加
                      ;转化成二进制为
                      ;   0 1 1 1 1 0 0 0
                      ; + 1 0 0 1 1 0 0 1
                      ; 1 0 0 0 1 0 0 0 1
                      ;由此可以看出状态标志位的转变
                      ; CF = 1 最高有进位
                      ; SF = 0 最高位为0
                      ; OF = 0 最高位和次高位没用同时进位或者借位
                      ; ZF = 0 不全为0
                      ; AF = 1 第四位想第五位有进位
                      ; PF = 1 第八位 1 的个数为偶数
                      ```
              
                      
              
                  - 带进位的加法指令 `ADC`
              
                    - 会影响 6 个状态标志位
                    - 格式  `ADC OPRD1, OPRD2` 即 将 OPRD1 和 OPRD2 的值相加赋予 OPRD1.
                    - `ADC` 和 `ADD` 的区别在于，`ADC` 用于多字节相加，因为其在计算过程中会附带状态标志位 `CF`， 所以使用前需要 `CF`先清零，为了防止 `CF`在加法之初就为 1
              
                  - 加1指令 `INC`
              
                    - 会影响 5 个状态标志位，不会影响 CF (carry flag, 进位符号位，表示最高位是否有进位或者借位)
                    - 格式 `INC OPRD`， `OPRD`不可以是立即数，也不能是段寄存器，因为其修改过程为 `OPRD` + 1 —>  `OPRD` ，一般用于程序中修改地址指针  
              
                  - 例
              
                    - 题目： 求内存数据段中 M1为首和M2为首的两个20字节数之和，并将结果写入M2为首的区域
              
                    - 解
              
                      ```
                      ;单字节
                      LEA SI, M1
                      LEA DI, M2
                      MOV CX, 20
                      CLC  ; 使得CF=0
                      NEXT: MOV AL [SI]
                      			ADC DI, AL
                      			INC SI
                      			INC DI
                      			DEX CX
                      			JNZ NEXT
                      			HLT
                      			
                      ;双字节
                      LEA SI, M1
                      LEA DI, M2
                      MOV CX, 10
                      CLC  ; 使得CF=0
                      NEXT: MOV AX [SI]
                      			ADC DI, AX
                      			ADD SI, 2
                      			ADD DI, 2
                      			DEX CX
                      			JNZ NEXT
                      			HLT
                      ```
              
                - 减法运算指令
              
                  - `SUB` 指令
              
                    - 格式 `SUB OPRD1, OPRD2`，即  `OPRD1` - `OPRD2` —> `OPRD1`
                    - 影响6个状态标记位，但不考虑借位状态，即不考虑 `CF`
              
                  - `SBB` 指令
              
                    - 格式 `SBB OPRD1, OPRD2`，即  `OPRD1` - `OPRD2` —> `OPRD1`
                    - 多用于多字节的相减，因为其考虑借位状态也就是CF，对应于加法运算中的 `ADC`
              
                  - `DEC` 指令
              
                    - 格式 `DEC OPRD1`，即  `OPRD1` - 1 —> `OPRD1`
                    - 只影响5个状态标识位，不影响 CF ( 对应于加法运算中的 `ADD` )
                  - 例
                  
                  ```
                    ; 延时(定时)
                    
                    			MOV BL, 2
                    NEXT1: MOV CX, 0FFFFH  ;这里 FFFFH 前面加 0，并不是表示地址，而是给编译器看的；如果一个立即数的最高位是 A～F，必须在前面加0，编译器才能认识。
                    NEXT2: DEC CX
                    			 JNZ NEXT2;
                    			 DEC BL;
                    			 JNZ NEXT1;
                    			 HLT;
                  ```
                  
                - `NEG` 指令
                  
                    - 格式 `NEG OPRD`，即  `0 - OPRD ` —> `OPRD`  
                    - 要求： 操作数为 8 / 16位寄存器或者存储器操作数
                    - 结论： 该指令在绝大多数情况下， CF = 1；表示有借位，只有在 `OPRD` 为 0 的时候， CF = 0；
                    - 补码知识回顾： 在计算机中，有原码 ，反码，补码。原码就是原来的数，反码就是对原码取反，补码(正数不变，负数就是在反码的基础上再减1)。为什么会出现反码和补码呢？因为在计算机中进行减法是什么不方便的，反码和补码的出现就是为了将减法转化为加法。其基于的原理就是时钟转动一圈之后就相当于重置了。因为计算机对于数的表示是有上限的( 8位，16位，32位等等)；当其超过了这个范围就会溢出，表现出来结果就是重置。所以对一个数，总是可以找到另一数与其对应。比如 时钟里的 3点； 就可以表示为 ( 24 - 21 )  因为 24 是一个周期，所以 3 等于 -21； 这里 3 就是原码； -21 就是补码。
                    
                  - `CMP` 指令
                  
                    - 格式 `CMP OPRD1, OPRD2` 
                    - 操作： 仅仅进行  `OPRD1 - OPRD2` 的操作，不会对操作数进行修改，也就是说，它**仅仅是用作影响标志位的**。
                    - 作用：一般是用做两个数比较大小。要注意的是，比较大小的时候，对比的两个操作数是有符号数还是无符号数。
                    - 比较大小
                      - 无符号数
                        - `CMP AX, BX` 
                        - 如果 AX  >=  BX;  不会产生借位， 所以 CF = 0；
                        - 如果 AX = BX； 不会产生借位，且其结果为 0；所以 CF = 0； ZF = 1；
                        - 如果 AX  < BX； 一定产生借位 CF = 1;
                        
                      - 有符号数
                        - `CMP AX, BX`
                        - 因为有符号数比较大小，需要考虑符号位，同时如果两个操作数符号不一样，相减则可能会产生溢出，所以两个数的大小由 OF 和 SF 共同决定
                        - OF (符号溢出标志) 和SF (最高位标志位) 状态相同(即异或为0) AX >= BX
                        - OF和SF状态不同(即异或为1) AX < BX
                        
                      - 程序例
                      
                        ```
                        		LEA BX, MAX
                        		LEA SI, BUF
                        		MOV CL, 20
                        		MOV AL, [SI]
                        NEXT: INC SI
                        			CMP AL, [SI]
                        			JNC GOON  ;CF = 0则跳转
                        			XCHG [SI], AL ;交换两个数
                        GOON: DEC CL
                        			JNZ NEXT
                        			MOV [BX], AL
                        			HLT
                        			
                        ```
                      
                  
                - 乘除运算法
              
                    - 与加减运算符的区别
                        - 在加减运算中，是否是符号数是通过看 `CF`,`ZF`,`OF`,`SF`来观察。而乘除运算中，有专门区分操作数是否有符号的助记符。
                        - 在乘除运算中，都是单操作数运算。
                        - 对于操作数的要求与加减法运算有所不同。
                    - 乘法指令
                        - 在乘法运算中，采用的是隐含寻址。隐含的是存放被乘数的累加器(AX，AL)以及结果输出的位置(AX或者DX)；也就是目标操作数为被乘数，目标操作数被隐藏了。默认的目标操作数是放在AX(或者AL)中。
                        - 要求：两个操作数的字长是一样的，也就是说如果给的源操作数是 8 位(1字节)，目标操作数也一定是 8 位(1字节)，同时不论他们运算的结果是什么，都用 16位(2字节)表示。同理 如果源操作数是 16位，则结果为 32位，高 16位存储在 DX中， 低 16位 存储在 AX中。
                        - 无符号数乘法指令
                            - 格式 `MUL OPRD`  `AL x OPRD` --> `AX` 或者 `AX x OPRD` --> `DXAX`
                        - 有符号数乘法指令
                            - 格式 `IMUL OPRD` `AL x OPRD` --> `AX`( AL 是商， AH是余数 ) 或者 `AX x OPRD` --> `DXAX`( AX 是商， DX是余数 )
                        - 指令执行原理
                            - 对操作数取补码
                            - 做乘法运算
                            - 将乘积按位取反加1
                    - 除法指令
                        - 在除法运算中，也采用的是隐含寻址。被除数隐含在AX,DX中
                        - 要求：被除数的位数一定是除数的两倍，比如如果除数是 8位，被除数必须是 16位。
                        - 无符号除法指令
                            - 格式 `DIV OPRD`  `AX / OPRD` --> `AX` 或者 `DXAX x OPRD` --> `DXAX`
                        - 有符号数除法指令
                            - 格式 `IDIV OPRD`  `AX / OPRD` --> `AX` 或者 `DXAX x OPRD` --> `DXAX`
              
                - 算术运算符小结
              
                    - 相同点
                        - 指令都会状态标志位，除了 `INC` `DEC` 不会影响 CF
                        - 对于操作数的要求都是：
                            - 如果是单操作数，操作数不可以是立即数，如果操作时存储器操作数，必须确定字长
                            - 双操作数的要求与一般指令一样
              
                - 程序例
              
                    ```
                    MOV SI, 1200H
                    MOV WORD PTR[SI], 8965H
                    MOV AL, [SI]
                    INC SI
                    MUL BYTE PTR[SI] ;BYTE PTR 确定字长为1字节，WORD PTR 确定字长为2字节，
                    ```
              
                    解释：将 1200H 立即数移入 SI； 将 双字节立即数 8965H 存入 SI中；将SI(地址为1200H)中的内容移入 AL；SI加一；将 单字节 SI与 AL相乘，结果存入 AX中。
              
                    即将乘积 3543H 存入 AX。
              
              - 逻辑运算和移位
              
                - 基本逻辑运算符
              
                  - 与、或、非
                  - 异或
                  - 说明：**除了‘非’运算外；逻辑运算会影响状态标志位。**在逻辑运算的过程中，每一个位都是相互独立的，也就是说不存在进位的情况，所以不会影响 AF的值。但是会影响 OF 以及 CF的值。虽然逻辑运算过程中，最高位不会有进位，也不存在溢出，但是会使得 OF=CF=0； 
                  - 对于操作数的要求与单/双操作数一样。
              
                - 逻辑运算指令
              
                  - ‘与’指令
              
                    - 格式 `AND OPRD1, OPRD2`, `OPRD1 AND OPRD2`--> `OPRD1`；有 0 则为 0。
              
                    - 应用
              
                      - 实现两个操作数按位相与
                      - 使得目标操作数的某些位不变，某些位清零
                      - 在不影响操作数的情况，使得 CF = 0; OF = 0; 
              
                    - 程序例
              
                      - 题目：从地址为 3F8H 端口中读入一个字节数，如果该数 bit1 位为1，则可以从 38FH 端口将 DATA为首地址的1个字输出，否则就不能进行数据传送
              
                      - 解
              
                        ```
                        			MOV DX 3F8H ;当端口地址超过8位的时候，必须将端口地址存放在DX中
                        WATT: IN AL, DX
                        			AND AL, 02H
                        			JZ WATT  ;ZF=1，转移
                        			MOV DX, 38FH
                        			MOV AX，DATA
                        			OUT DX, AX
                        ```
              
                  - 或运算指令
                  
                    - 格式 `OR OPRD1 OPRD2` `OPRD1`  OR `OPRD2` --> `OPRD1`, 有1则为1.
                  
                    - 应用
                  
                      - 实现两个操作数按位相或
                      - 使得目标操作数的某些位不变，某些位变成 1
                      - 在不影响操作数的情况，使得 CF = 0; OF = 0; 
                  
                    - 程序例
                  
                      - 题目：将一个二进制数 9 变为字符 '9'
                  
                      - 解
                  
                        ```
                        ;字符 9 的ASCII码为 39H
                        MOV AL 9H;
                        ；方案1
                        MOV AL 39H
                        ；方案2
                        ADD AL 30H
                        ；方案3
                        OR AL 30H
                        ```
                  
                  - 非运算
                  
                    - 格式 `NOT  OPRD`, 将操作数按位取反送回原地址
                    - 指令对标志位没有影响
                  
                  - 异或运算符
                  
                    - 格式 `XOR OPRD1 OPRD2` 无进位相加
                  
                  - ‘测试’指令
                  
                    -  格式 `TEST OPRD1 OPRD2`
                    - 执行与运算，但是计算结果不送回目标地址，也就是仅仅影响标记位
                    - 应用：
                      - 常用于测试某些位的状态
                  
                  - 程序例
                  
                    - 题目：从地址为3F8H的端口读入一个字节数，当概述  的 bit1，bit3，bit5同时为1时，可从38FH端口将DATA首地址的一个字输出，否则不能进行数据传送。
                  
                    - 解
                  
                      ```
                            LEA SI DATA
                            MOV DX 3F8H
                      WATT: IN AL, DX
                            AND AL, 2AH
                            CMP AL, 2AH ;或者 XOR AL，2AH
                            JNZ WATT
                            MOV DX, 38FH
                            MOV AX, [SI]
                            OUT DX, AX
                      ```
                  
                - 移位操作指令
              
                  控制二进制向左向右移动的指令
              
                  - 操作数： 移位指令在格式上是双操作数指令，但是实质上是单操作数指令。其目标操作数就是需要计算的操作数，但是源操作数是是要位移的次数。由此，该类指令的目标操作数必须是指定长度的存储器操作数或者寄存器操作数，源操作数如果是1，可以由立即数给出，如果不是1则必须存放在CL中。
                  - 非循环移位指令
                    - 逻辑左移
                      - 原理：对目标操作数进行乘法工作，移动移位乘以2。移动的时候最高位存放在CF中，最低位补0. 从本质上来说，逻辑左移和算术左移没有区别。在概念上来说逻辑左移和算术左移，前者针对无符号数，后者针对有符号数。
                      - `SHL OPRD 1`
                      - `SHL OPRD CL`
                    - 算术左移
                      - `SAL OPRD 1`
                      - `SAL OPRD CL`
                    - 逻辑右移
                      - 针对无符号数右移，最低位存放在CF中，最高位补0
                      - `SHR OPRD 1`
                      - `SHR OPRD CL`
                    - 算术右移
                      - 针对有符号数，最低位存放在CF中，最高位补的数是符号位上的数
                      - `SAR OPRD 1`
                      - `SAR OPRD CL`
                    - 应用
                      - 左移实现乘法
                      - 右移实现除法
                  - 循环移位指令
                    - 不带进位位的循环移位, 将要最高位(最低位)移动到CF同时移动到最低位(最高位)
                      - 左移 `SOL OPRD 1/CL`
                      - 右移 `SOR OPRD 1/CL`
                      
                    - 带进位的位循环移位 将要最高位(最低位)移动到CF，同时将CF的值移动到最低位(最高位)
                      - 左移 `SCL OPRD 1/CL`
                      - 右移 `SCR OPRD 1/CL`
                      
                    - 应用
                      - 用于对某些位状态的测试
                      - 高尾部分和低位部分的交换
                      - 与非循环移位指令一起组成32位或者更长字长数的位移
                      
                    - 代码例
                    
                      - 题目：在内存数据段 M1 为首地址的4个单元中存放了 4 个压缩 BCD码。要求：将这 4 个压缩 BCD码分别转换为 ASCII码。 并将转换结果存放在同一逻辑段、 M2为首的单元中    
                    
                      - 分析：
                    
                        压缩BCD码是使用 4 bit 的二进制来表示 1 个十进制数，要将其转化为ASCII 码，需要分开转化其高四位和低四位；ASCII码表示 0～9 的高四位是 0011；所以可以先将 BCD码高四位置0，再将高四位变为 0011；如此完成低四位的转化；高四位转移到另一个寄存器的低四位，同理进行转化。
                    
                      
              
              - 串操作
              
                - 说明： 串操作指令主要针对的是数据块或者字符串，由于数据量大，所以数据一般存储在存储器中，因此串操作实现了存储器到存储器的数据传送，也就是说对一串操作命令来说，其目标地址和源地址都是存储器操作数。
              
                  对于操作数来说，待操作的数据串称为源串，目标地址称为目标串；执行该指令需要确定：
              
                  - 串所在的区域
              
                  - 串的长度
              
                  - 串的首地址
              
                  - 操作的方向：由于串操作的操作数都是多字节的，所以，在操作的过程中不可能一次性完成操作，并且，在串操作的过程中，没办法自定义指针的指向，指针移动的方向都是已经在指令中定义的，只有在使用指令的最初来定义指针是增量移动还是减量移动
              
                  - 操作数要求
              
                    - 源串一般放在数据段，偏移地址由 SI 指定。允许段重设
                    - 目标串必须在附加段，偏移地址由 DI 指定
                    - 串长度值由 CX 指定
                    - 串的操作方向由 DF标志位决定，指令根据 DF状态自动修改地址指针；DF = 0表示增地址方向， DF = 1 表示减地址方向
              
                  - 重复前缀：串指令前面添加重复前缀可以重复执行该条串命令
              
                    - 无条件重复：常用于传送指令
                      - `REP` 当 CX 不等于 0时，`REP` 后面的指令将继续重复执行
                    - 条件重复：常用于运算类别指令
                      - 相等( 相减为0 ) 重复 `REPE` 或者 `REPZ`，CX 不等于 0并且 ZF = 1时，串指令重复
                      - 不相等 (相减不为 0 ) 重复，`REPNZ` 或者 `RPENE`，CX不等于0并且ZF = 0时重复
              
                  - 串指令
              
                    - 串传送指令: 将源数据串传送到目的地址
              
                      - `MOVS OPRD1, OPRD2`, `MOVS [DI], [SI]`，需要对源操作数进行段重设时才采用该条命令
              
                      - `MOVSB` 以 bit 为单位
              
                      - `MOVSW` 以字节为单位
              
                      - 程序例: 分别用 `MOV` 指令和 `MOVS` 指令编写将200个字节数据从内存数据段 MEM1 为首地址的区域送到同一逻辑段 MEM2 为首地址的区域中
              
                        ```
                        ;使用 MOV 指令
                        LEA SI, MEM1
                        LEA DI, MEM2
                        MOV CX, 200
                        NEXT: MOV AL, [SI]
                        			MOV [DI], AL
                        			DES CX
                        			INC SI
                        			INC DI
                        			JNZ NEXT
                        HLT
                        
                        ;使用 MOVS 指令
                        LEA SI, MEM1
                        LEA DI, MEM2
                        MOV CX 200
                        CLD ;将 DF 清零，于是重复传送指令的操作方向是增地址方向
                        REP MOVSB
                        HLT
                        ```
              
                    - 串比较指令：用于实现两个数据串的比较
              
                      - 使用 **目标串** 减去 **源串**； 结果丢弃，不写回目标地址
                    
                      - 常与条件重复前缀连用
                    
                      - `CMPS OPRD1, OPRD2`
              
                      - `CMPSB`
              
                      - `CMPSW`
                    
                      - 程序例
              
                        - 题目：测试上例中 200 个字节数据是否传送正确
                    
                        ```
                        ;使用 MOVS 指令
                        LEA SI, MEM1
                        LEA DI, MEM2
                        MOV CX 200
                        CLD ;将 DF 清零，于是重复传送指令的操作方向是增地址方向
                        REPE CMPSB
                        JZ STOP	;判断 ZF 是否等于 1； 等于 1 则跳转
                        DEC SI
                        MOV AL, [SI]
                        MOV BX, SI
                        STOP: HLT
                        ```
                    
                    - 串扫描指令：常用于在指定区域中寻找某个关键字
                    
                      - 格式
                    
                        - `SCAS OPRD`
                        - `SCASB`
                        - `SCASW`
                    
                      - 执行 `SCAS` 与执行 `CMPS` 指令相似。区别是这里的源操作数是 AX 或者 AL。
                    
                      - 程序例
                    
                        - 题目：在ES端中从 2000H 单元开始存放了10个字符，寻找其中有无字符 'A', 若有则记下搜索次数，将搜索次数写入到 DATA1 单元，并将存放 'A' 的地址写入 DATA2 单元
                    
                        ```
                        MOV DI, 2000H
                        MOV BX, DI
                        MOV CX, OAH
                        MOV AL, 'A'
                        CLD
                        REPNZ SCASB
                        JZ FOUND
                        MOV DI, 0
                        JMP DONE
                        FOUND: DEC DI
                        			 MOV DATA2, DI
                        			 INC DI
                        			 SUB DI, BX
                        DONE: MOV DATA1. DI
                        			HLT
                        ```
                    
                    - 串装入指令
                    
                      - 格式 
                        - `LODS OPRD` ，这里是源操作数，指针在 SI
                        - `LODSB`
                        - `LODSW`
                      - 操作：将 SI 中内容送给 AL/AX
                      - 作用是将内存中某个区域的数据串依次装入累加器，以便显示或输出到接口
                      - LODS 一般不加重复前缀，因为如果添加重复前缀，重复装入内容到累加器( AX/AL )，后面的内容会把前面的内容覆盖
                    
                    - 串存储指令
                    
                      - 格式
                        - `STOS OPRD`
                        - `STOSB`
                        - `STOSW`
                      - 操作：将 AL/AX 送到 DI 所指的位置
                      - 常用于将内存某个区域置同样的值
    
    - ### 程序控制类指令
        本质上：控制程序要不按照正常的顺序执行，而是改变程序的运行方向; 由于计算机运行的顺序是由 PC 也就是 IP 指针所确定的，同时运行的代码是一般是放在代码段中也就是 CS 中，所以，改变程序的走向也就是改变 IP 或者 CS 的值。所以，本章的重点在于 **程序如何修改 CS 以及 IP 的值**
        
        指令类别
        
        - 转移指令
        
            ​	通过修改指令的偏移地址，或者修改程序的段地址以及偏移地址来实现程序的转移
        
            - 无条件转移指令
        
                - `JMP OPRD` OPRD是目标地址
                    - 段内直接转移， 转移的目标地址由指令直接给出(立即数)。格式是 `JPM LABEL`; 下一条要执行的指令的偏移量地址是 当前 IP + IP到LABEL的位移量
                    - 段内间接转移，转移的目标放在某个16位寄存器或存储器的某两个单元中
                    - 段间直接转移，目标地址为32位，包括段基地址(高地址)和偏移地址(低地址)。格式是 `JPM FAR LABEL`；有
                        FAR表示远地址，也就是段基地址在其他段。
                    - 段间间接寻址，格式 `JMP DWORD PTR[BX]`
        
            - 条件转移指令
        
                满足一定的条件，是的程序转移到目标地址。转移范围是 ( -128 ~ 127 );    
        
                -  基于1个标志位状态实现转移
                  - `JC/JNC` 基于CF；常用于两个无符号数大小比较
                  - `JZ/JNZ` 基于 ZF；常用于循环体的结束判断
                  - `JO/JNO` 基于OF；常用于有符号数溢出的判断
                  - `JP/JPE`, `JNP/JPO` 基于PF；用于判断运算结果低8位中，1的个数是否为偶数
                  - `JS/JNS` 基于SF；常用于判断数的性质
                -  基于2个或者3个标志位状态实现转移
                   -  `JA/JAE/JB/JBE`；判断CF或CF+ZF的状态，无符号数比大小
                   -  `JG/JGE/JL/JLE`；判断SF+OF或者SF+OF+ZF的状态，有符号数比大小
                -  基于CX内容转移的指令
                   -  `JCXZ` 可根据指令执行后CX的结果实现转移 
        
        - 循环控制
        
            - 循环范围：以当前IP为中心的 -128 ～ +127 范围内循环
            - 循环次数：由CX寄存器指定
            - 循环指令
                - `LOOP LABEL` 无条件循环指令，LABEL是下一条要执行指令的地址，当 CX 不等于 0 时循环。该指令默认每一次循环会将 CX 减 1；
                - `LOOPZ LABEL` 同样在每次循环前会使得 CX 减 1，同时循环的条件时 CX 不等于 0， 同时也要看 ZF 的值；
                - `LOOPNZ LABEL` 同样在每次循环前会使得 CX 减 1，同时循环的条件时 CX 不等于 0， 同时也要看 ZF 的值；
        
        - 过程调用
        
            - 在汇编中，过程也称为子程序，过程调用也就是调用子程序。
            - 与转移指令的对比：过程调用结束后要返回原调用处，所以在调用子程序的时候，就要保护好原调用处。
            - 过程调用的过程：首先找到要调用的子程序的第一条命令的地址(入口地址)，执行子程序，结束子程序的执行后返回原调用处的下一条命令的地址(断点)。
                - 保护断点：将调用指令的下一条指令的地址(断点)压入堆栈。
                - 获取子程序的入口地址：子过程第1条指令的地址
                - 执行子程序：功能实现，参数的保存和恢复
                - 恢复断点，返回原程序：将断点偏移地址由堆栈弹出
            - 指令
                - 段内调用：被调用程序和调用程序在同一个代码段中，所以段内调用不需要保护段基地址，只需要保护偏移地址。
                    - 直接调用：与间接调用的区别在于，子程序的入口是直接给出的还是间接给出的。
                      - 格式 `CALL TIMER` 用一个标签 TIMER 表示偏移地址
                    - 间接调用
                      - 格式 `CALL WORD PTR[SI]` 
                - 段间调用：子过程与原调用程序不在同一代码段，调用前需要保护断点的段基地址和偏移地址。保护段基地址和偏移地址是指吧他们压入堆栈，先压入断点的CS(段基地址)，再压入IP ( 偏移地址 )
                    - 直接调用
                      - 格式 `CALL FAR TIMER`
                    - 间接调用
                      - 格式 `CALL DWORD PTR[SI]`
                - 返回指令
                    - 功能： 从堆栈中弹出断点地址，返回源程序
                    - 格式 `RET`
                    - 子程序最后一条指令必须是 `RET`
        
        - 中断控制
        
            - 中断的概念
                - 因为一些异常或者随机事件，迫使cpu停止正在运行的程序，转而去执行一段特殊处理程序，并在处理结束后返回原程序被中断处继续执行原程序的过程。
                - 中断指令：引起CPU产生一次中断的指令
            - 中断与过程调用
                - 相似点，中断和子程序调用都是cpu在执行原代码的时候，保护断点后，转而去执行另外一段代码，执行结束后会返回原程序。
                - 区别
                    - 过程调用是有程序员设计好的，是事先就可以很清楚的知道什么时候发生的。而中断是一种随机的，异常的状况发生后，cpu转而去执行一段专门应对与该种状态的代码。处于这种原因，一般程序员编写中断代码的时候可能会出现两种原因：1、异常发生，永远不希望被执行的代码；2、随机发生，不知道什么时候会发生的事情。
                    - 子程序的入口给出方式不一样，过程调用是由代码直接或者间接的给出的；而中断只是给出了子程序的入口的向量码，入口地址则在向量码只想的内存单元中。
                    - 过程调用可以是近地址或者远地址，中断一定是远地址，也就意味着断点保护一定包括段基地址和偏移地址。
                    - 中断请求还需要保护 FLAGES 的内容
                - 指令
                    - `INT n` n是一个状态码，范围 0～255； n * 4 以及 n * 4 + 1 表示存放中断服务子程序入口地址的单元的偏移地址;  n * 4 + 2 以及 n * 4 + 3 表示段地址
                - 指令指令过程
                    - 将 FLAGES 的内容压入堆栈
                    - 将中断命令下一条指令的 CS，IP压入堆栈
                    - 获得中断命令的向量码：n * 4；
                    - 将中断程序的 IP， CS 放入寄存器中
                    - 执行中断程序
                - 中断返回指令
                    - `IRET`：恢复断点，恢复标志寄存器内容
            
        - 处理器控制指令
        
            用来对CPU进行控制。比如修改标志寄存器，使CPU暂停，使CPU与外部设备同步等。
        
            - `CLC`: CF -> 0
            - `STC`: CF -> 1 
            - `CMC`: CF取反
            - `CLD`: DF -> 0
            - `STD` DF -> 1
            - `CLI` IF -> 0
            - `STI` IF -> S

- ## 汇编语言源程序

  - #### 汇编语言源程序: 由汇编语言编写的程序代码，后缀名: .ASM

  - #### 汇编程序: 将汇编语言源程序转变成电脑可识别的机器语言的一个系统程序，后缀名: .OBJ

  - #### 链接： 将汇编程序中所需要的各个库进行装入，生成一个可执行的文件，后缀名: .EXE 

  - #### 汇编语言语句语句类型和格式

    - 语句类型

      - 指令行语句: CPU 执行的语句，能够生成目标代码
      - 指示性语句: CPU不执行的语句，比如怎么样分配内存空间，程序从哪里开始到哪里结束。是由汇编程序执行的语句，不生成目标代码

    - 汇编语言语句格式

      - 指令行语句: `[标号:] [前缀] 助记符 [操作数], [操作数][；注释]`

        以上方括号表示，可以有可以没有，即可选项。标号后面必须要有冒号。
        
      - 指示性语句: `[名字] 伪指令助记符 操作数 [, 操作数, 操作数, ...] [; 注释]`
      
        **名字** 后面不接 **冒号**，指示性语句至少有一个操作数，可以有多个，大小限制就是不可以超过所在段的段大小。
      
    - 汇编语言语句中的操作数
    
      - 寄存器操作数
      - 存储器操作数
      - 常量：数字常量，字符串常量；
      - 变量和标号
        - 变量：内存单元的符号地址，是存储器操作数，属性：段值，偏移量，类型(字节型，字型，双字型)；
      - 表达式：算术运算，逻辑运算，关系运算，取值运算和属性运算(`PTR`)，其他运算
    
  - #### 数据定义伪指令
  
    - 伪指令：由汇编程序指令的 **指令系统**。不会被翻译成机器语言。目的：帮助计算机理解汇编语言源程序
  
      - 作用：
  
        - 定义变量
        - 分配存储区
        - 定义逻辑段
        - 指示程序开始和结束
        - 定义过程
  
      - 常用伪指令
  
        - 数据定义伪指令
  
          - 定义数据区中，变量的类型以及所占用内存的大小，存储的过程都是有低地址向高地址的顺序。
  
          - 格式 `[变量名] 伪指令助记符 操作数, ... ;[注释]`
  
            - `DB` ( Define Byte ) 定义的变量为字节型
            - `DW` ( Define Word ) 定义的变量为字类型
            - `DD` ( Define Double Word) 定义的变量为双字型
            - `DQ` ( Define Quadword ) 定义的变量为4字型
            - `DT` ( Define Tenbytes ) 定义的变量为10字型
  
          - 例
  
            - `DATA1 DB 11H, 12H, 13H`
            - `DATA2 DW 11H, 12H, 2323H`
            - `DATA3 DD 23h * 2, 2323H, 23235656H`
  
            可以看的出，上述变量的类型声明之后，如果给变量所赋的值是 11H， 但是其伪指令助记符为 `DW`, 则其应该是 0011H。在内存中的存储形式也应该是这个样子的。
  
          - 说明
        
      - 定义字符串必须由 `DB` 来定义。
    
  - 重复操作符号
        
          - 作用：为一个数据区的各单元设置相同的初值
          - 格式：`[变量名] 伪指令助记符 n DUP (初值 [,初值 ...])`; n表示重复的次数，DUP表示重复的运算符，初值是重复的内容
          - 例 
      - `M1 DB 10 DUP (0)`, 定义了一个以 M1 为初始地址的，10个变量，初始值全部为 0；
      
  - 问号 `?`
        
          - 表示随机值，用于预留存储空间
          - 例
      - `MEM1 DB 34H, 'A', ?` 也就是表示一个占位符。
      
  - 符号定义伪指令
        
    - 将表达式的值赋给一个名字。当源程序中需多次引用某一表达式时，可以利用 `EQU` 伪指令， 用一个符号代替表达式，以便程序维护。
          - 格式： `符号名 EQU 表达式`， `EQU` 就是 equal 的缩写。
    - 操作： 用符号名取代后面的表达式，类似于给变量赋值，但是与变量不一样的是，变量在后期可以重新定义，而符号不可重新定义。同时， **采用该方法系统不会给符号在内存中分配空间，但是如果是给一个变量赋值，系统会在内存中给该变量分配存储空间**。
      
      - 例 `CONSTANT EQU 100`, CONSTANT 就表示 100。如果要改变值，就要重新编译。
      
        - 段定义伪指令
        
          - 作用：在汇编语言源程序中定义逻辑段，说明逻辑段的起始和结束，不同程序模块中同类逻辑段的联系形态。
          
          - 格式： `段名 SEGMENT [定位类型] [组合类型] ['类别']`
          
            ​					`  ...`
          
            ​			`段名 ENDS`
          
            - 段名：逻辑段的段基地址
            - `SEGMENT`：指的是代码片段
            - 定位类型：逻辑段的起点
            - 组合类型：装入内存时，不同的逻辑段的组合方式，默认不组合
            - 类别：字符串，链接的时候，不同程序模块中的同类逻辑段将被装入连续存储区中
          
          - 程序例
          
            ```
            DATA SEGMENT ;段基地址由于是由操作系统统一分配，程序员不能自行设定，所以段名使用符号代替,这里没有指定是哪一个逻辑段，只是把他们都放在同一个逻辑段中
            	MEM1 DB 11H, 22H
            	MEM2 DB 'HELLO'
            	MEM3 DW 2 DUP (?)
            DATA ENDS
            ```
          
          - 设定段寄存器伪指令
          
            - 说明所定义逻辑段的性质
            - 格式 `ASSUME 段寄存器名：段名 [, 段寄存器名：段名]`，段寄存器名就是四个段寄存器: CS, ES...
        
        - 结束伪指令
        
          - 表示程序结束
          - 格式： `END [标号]`
        
        - 过程定义伪指令
        
          - 定义一个子过程
          
          - 格式
          
          ```
          过程名 PROC [NEAR/FAR]
          
          ...
          			RET ；return 指令，不可省略
          过程名 ENDP
          ```
          
           **过程名** 代表着这个过程的入口地址。 **NEAR/FAR** 表示为 近过程体(可以省略) / 远过程体
          
        - 调用例
        
          ```
          ;定义延时子程序
          DELAY PROC    ；声明的子程序符号
          			PUSH BX ；在该子程序中会使用 BX以及 CX两个通用寄存器，为了通用的原则，所以在开始程								序之前必须要保护那些被使用的寄存器或者其他的值，这里需要把 BX 和 CX中的值								保存下来，以便结束该子程序的时候可以还原，不会影响其他程序的执行
          			PUSH CX
          			
          			MOV BL, 2      ；执行定时子程序的代码
          NEXT: MOV CX, 4167
          W10M: LOOP W10M
          			DEC BL
          			JNZ NEXT
          			
          			POP CX				；还原现场
          			POP BX
          			RET 					；return
          DELAY ENDP
          
          ；调用子程序
          CALL DELAY
          ```
        
          
        
        - 宏命令伪指令
      
            - 宏：源程序中由 **<font color='red'>汇编程序识别的</font>**  **<font color='orange'>具有独立功能</font>** 的一段 <font color='yellow'>程序代码</font>
      
            - 使用场景： 当源程序中需要多次使用同一个程序段时，可以将该程序段定义为一个宏
      
            - 宏与子程序的异同：
      
                - 相同点：都是具有独立功能的一段程序代码，类似于函数
      
                - 不同点：子程序不依赖于特定的一个源程序，通过编译链接可以被任何的源程序所使用，也就是说，子程序可以被编译链接成一个独立的可执行的文件。但是宏不行，虽然宏也是一段独立的程序代码，但是宏只能是特属于某一个源程序，但是在该源程序反复使用，所以被提炼出来。但是只能被该源程序所调用，通过参数传递的方式来调用的。
      
                - 格式： 
      
                  ```
                  宏命令名 MACRO <形式参数>
                      .... ；宏体
                          ENDM
                  ```
      
                  ```
                  DADD MACRO X,Y,Z
                  	   MOV AX, X
                  	   ADD AX, Y
                  	   MOV Z, AX
                  	   ENDM
                  	   
                  ；调用宏
                  DADD DATA1, DATA2, SUM
                  ```
      
              - 调用形式，系统在编译的过程中会将调用宏的命令用宏体来替代，这个过程称为宏展开。所以，使用宏之后，不会减少代码编译完成后的文件大小，只会减少编写的时候的书写量。上述代码宏展开后为
      
                ```
                MOV AX, DATA1
                ADD AX, DATA2
                MOV SUM, AX   
                ```
      
      - 调整偏移量伪指令
      
        - 规定程序或变量在逻辑段中的起始地址，默认条件下，程序或变量在逻辑段中的起始偏移地址为 0；
      
        - 格式 ：`ORG 表达式` 表达式的结果一定要是一个非负的常数
      
        - 例
      
          ```
          DATA SEGMENT
          		ORG 1200H
          		BUFF DB 1,2 ;如果不使用 ORG 命令，变量 BUFF 的偏移地址为0， 使用之后， BUFF 的偏移									地址变为 1200H
          DATA ENDS
          ```
      
          
      
        - 汇编语言源程序结构
      
          ```
          数据段名 SEGMENT
          	...
          数据段名 ENDS
          附加段名 SEGMENT
          	...
          附加段名 ENDS
          堆栈段名 SEGMENT
          	...
          堆栈段名 ENDS
          代码段名 SEGMENT
          	...
          代码段名 ENDS
          				END
          ```
      
          ```
          DSEG SEGMENT ;定义数据段，如果使用内存则必须定义
          	DATA1 DB 1,2,3 DUP(?)
          	DATA2 DW 1234H
          DSEG ENDS
          
          ESEG SEGMENT ；定义附加段，如果使用串操作则必须定义
          	DB 20 DUP (?)
          ESEG ENDS
          
          SSEG SEGMENT	；定义堆栈段，如果使用中断指令，异常处理则必须定义
          	DB 200 DUP (?)
          SSEG ENDS
          
          CSEG SEGMENT	；定义代码段
          	ASSUME CS: CSEG, DS: DSEG, ；将定义的逻辑段分别赋给段寄存器
          				 ES: ESEG, SS: SSEG
          
          START: MOV AX, DSEG	； 完成上述操作，计算机并不会为代码分配内存，必须初始化，也就是通过通用寄											  存器给段寄存器赋值
          			 MOV DS, AX
          			 MOV AX, ESEG
          			 MOV ES, AX
          			 MOV AX, SSEG
          			 MOV SS, AX
          			 
          			 ... ;一些执行代码，要执行的源程序在写在该处
          			 
          CSEG ENDS
          		 END START ；必须写的程序结束命令， START 表示标号，START标记的地方是程序开始的第一段代									 码。标号可以自定义，也可以是 NEXT 或者其他。
          ```
      
    
  - #### 系统功能调用
  
      系统功能调用主要是指调用 **系统BIOS** 或者 **系统内核** 的一些 **功能**。
  
      - BIOS (Base Input Output System 基本输入输出)
        - 定义：驻留在 ROM 中的基本输入输出系统。他是一段程序代码，随着芯片出厂便附着在芯片上，随着开机会自动运行。早起的 BIOS 是使用光刻技术刻在芯片上的，所以早期的 BIOS 是不可以被修改的，只允许被砸烂。现代的 BIOS 是存储在可写的只读硬盘里。
        - 功能： 
          - 加电自检，开机后，BIOS 系统会引导计算机进行自我检测。
          - 装入引擎，BIOS会运行操作系统程序，将操作系统的程序由硬盘引导到内存中。BIOS 中存储开机后运行第一条指令的地址，即 IP 指针的初始值时候 BIOS 赋予的。
          - 主要 I/O 设备处理程序及接口控制，BIOS会接管主要的输入输出接口等。
      - DOS
  