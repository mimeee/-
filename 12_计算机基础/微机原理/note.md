# 微型计算机系统

## 目录

1. [微型计算机是什么](note.md#微型计算机是什么)
2. [微型计算机的组成](note.md#微型计算机的组成)
3. [微型计算机的工作过程](note.md#微型计算机的工作过程)
4. [冯诺依曼计算机](node.md#冯诺依曼计算机)

- ## 微型计算机是什么

  在平时我们使用的个人计算机等就是微型计算机。

- ## 微型计算机的组成

  微型计算机系统由 **硬件系统** 和 **软件系统** 两个部分组成。计算机和计算机系统不是一样的概念。计算机只是包含计算机硬件。

  - #### 硬件系统

    硬件系统包括 **<font color="yellow">主机系统</font>** 和 **<font color="yellow">外部设备</font>**。  
    
    1. **外部设备** 是指能够和计算机进行信息交换，同时又不能直接和计算机进行信息交换，需要通过第三方进行(简单的说外部设备不能直接和cpu进行交换，必须通过输入输出接口，例如鼠标，打印机等等)。 

    2. **主机系统** 包括：

       1. **<font color="#a890f5">cpu</font>**(微处理器): 运算器，控制器，寄存器
       2. **<font color="#a890f5">存储器</font>**: 内存，外存(联机外存(硬盘，如SATA)，脱机外存(移动硬盘))
  
  关于内存储器

  - 表现形式: 内存储器的物理表现形式是有一个一个的黑块块，这些黑块块就是内存芯片。
   ![storage](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190524_1.png)
  
    内存储器的逻辑表现形式是：他是按照单元组织的，每个单元对应于一个内存地址。每个单元的容量都是一样的，即为1字节(1byte = 8bit)。可以把内存条想象一幢大厦，里面的房间想象成单元，房间的门牌号(唯一的)想象成单元地址(唯一的)，房间可容纳的人想象成单元容量。
  
   - 内存操作：读和写；读操作的过程是一个复制的过程，cpu读取内存中的数据是从内存中把数据复制过来，不会对内存中的数据进行破坏。写操作则是是一个破坏性的操作。
       - 分类
         - 随机存取存储器(RAM)：随电而生，随电而亡
     - 只读存储器(ROM)：u盘，不需要电，写操作由条件
       3. **<font color="#a890f5">输入输出接口</font>**(I/O system): CPU和外部设备通信的桥梁  cpu <------> I/O接口 <--------> 外设
  
   - 存在的理由：由于cpu运行速度很快，但是外设的运行速度很慢。如果让cpu取迁就外设，那电脑就没办法用了，于是就有了输入输出接口来平滑这个速度差。平滑的方式就是像暂存区一样，首先接口是专用的，cpu咵的一声就把数据丢到那里了，外设在自己慢慢的从接口中挪数据。而如果是取数据则是，外设慢慢的把数据放在接口处，放完告诉cpu，cpu又咵一声取走了。这样不会耽误cpu干其他事。
     
       - 主要功能：数据换成寄存；信号电平或类型的转换；实现主机和外设间的运行匹配。
    4. **<font color="#a890f5">总线</font>**
          总线上跑的都是高低电平(也就是0,1)，由于他就像是马路，信息就像是车子，马路就这么宽，而车(信息)有很多，所以总线总是存在着争用。所以总线要有裁判的功能。
  


- ## 微型计算机的工作过程
    无论程序是由什么语言编写，到了计算机去实现的时候，都是转变成了一条一条0,1的指令序列。
    - 计算机的工作过程(外存，内存，cpu)
        - 指令的编写: 在今天，我们所编写的程序要想让电脑(cpu)执行，必须存放在内存中。因为只有内存才可以和cpu进行交换。而编写完的程序一般是放在硬盘中，交给内存的程序都是经过0,1编码转化成一条一条语句，在转交给内存。
        - 计算机执行指令的过程
            - <font color="red">获取指令(核心)</font>
            - <font color="red">指令译码(核心)</font>
            - 获取数据
            - <font color="red">执行指令(核心)</font>
            - 存放结果
        - 指令执行顺序: 顺序，并行;
            - 顺序执行：指令完成一个在进行下一个
            - 并行执行：总线在运送完指令后，不等待指令完成就去运送下一个。
            - 加速比：两种方式的执行时间的比值
            - 为什么会有两种并行的指令执行顺序？原因在于cpu在完成人们需求的过程中分为了上述5步，而获取指令是通过总线来把数据从外存拉到内存进行中，然后再进行指令译码以及执行指令的过程。在这个过程中，如果是顺序的执行顺序，也就是说完成一个指令再执行下一个指令，会导致总线在指令译码以及执行指令的过程中空闲。所以为了提高总线的利用率，就有了并行的执行顺序。
    
- ## 冯诺依曼计算机

    #### 原理：存储程序原理

    #### 计算机的一般工作过程

    参与工作的部件：寄存器( pc， AR， DR...)，存储器，控制器，总线，运算器

    相关部件的解释：

    - pc: (也相当于一个寄存器)里面存储着要运算的程序的第一条指令的地址，他的作用就是指针，指向程序存储的地址。

    - AR: 用来暂存地址的暂存器

    - DR：用来赞成数据的暂存器

    过程：

    pc将指令地址传送给AR，AR通过地址去访问该内存单元的内容，控制器下指令取出该内容，并进行指令译码。根据指令进行动作，如有结果输出则送至输入输出接口。

    

    #### 不足

    1. pc将指令传给AR，证明寄存器之间交互很多，所以对总线要求很高
    2. 由程序控制执行顺序，表示不适合高并发的复杂程序。
    3. 由运算器为核心，运算效率不高



- ## 数值及其转化

  - 二进制，八进制，十六进制转化为十进制

  由每个位乘以该进制的位的序号减一次幂，相加。比如：

  1010B = 0 * 2的<font color = 'red'>0次幂</font> + 1 * 2的的<font color = 'red'>1次幂</font>+ 0 * 2的<font color = 'red'>2次幂</font> + 1 * 2的<font color = 'red'>3次幂</font> = 10

  - 十进制转化为二进制

  用十进制除2取余。小数的话则是乘2取整。

  100.2; 分成 100 以及 0.2；

  100转成二进制为： 

  100 /2 = 50 ……0   

  50 /  2 = 25 ……0

  25 /  2  = 12 ……1

  12  / 2   = 3  ……0

  3   /  2   =  1 ……1

  1  /  2    =  0 ……1

  0.2转成二进制为： 

  0.2 * 2 = 0.4   0

  0.4 * 2 = 0.8   0

  0.8 * 2 = 1.6   1

  0.6 / 2 = 1.2   1

  0.2 * 2 = 0.4   0

  ……

  所以最后结果为110100.00110…..

  - 二进制转化为八进制，十六进制

  二进制中四位表示十六进制一位

  二进制中三位表示八进制一位

- ## 编码

  - 编码就是把一种数据合格转换成另一种数据格式。比如把十进制转成二进制。编码的原因是因为计算机智能识别高低电平也就是0和1，所以为了让计算机认识指令，任何数据格式都要处理成0和1的格式。但0和1对于人却不太友好，所以当我们编程的时候，需要把我熟悉的数据格式转换成计算机熟悉的数据格式。

  - #### 主要的编码格式：

    - 二进制编码：用二进制存储的数据格式

    - BCD编码( Binary Coded Decimal )：使用0和1的数据，但是保留逢10进1的规则。其主要也是给人看的。计算机不可以识别该编码。比如 *0001 1001*表示19(十进制)

      - 要达到这个目标就必须要使用 **4位二进制** 来表示1个BCD 编码。因为 3位二进制码最多只能表示到8；而4位二进制码可以表示到16；所以10以上的二进制码是无效的，即 1010 到 1111 都是无效的。
      - 由于用 **4位二进制码** 表示一个数，根据每位的权值(2的幂)也称该编码位 **8421BCD编码**；
      - **转化**：将BCD编码转化成二进制，需要先转化成十进制。
      - **存储**：
        - 压缩BCD码：因为使用4位二进制来表示一个十进制的数，而计算机一个字节是8位，所以一个字节可以存放两个BCD码。当一个内存单元存放两个BCD码，就称作压缩BCD码
        - 扩展BCD码：一个内存单元存放一个BCD码，高位多出的4位使用0补齐，就称为扩展BCD码。

      

    - ASCII编码

      - 格式：由字母，数字，标点，控制器组成，由8位二进制来表示的编码。一般只使用7位，高位默认为0.
      - 校验：奇偶校验：为了防止在传送中出现错误，在8位二进制的最高位使用 **0**和 **1**来表示有  **偶数**或者 **奇数**个1.即最高位使用 0表示由偶数个1，使用1表示由奇数个1.



 - ## 数的表示和运算

    - #### 按数的表示方法分

       - 定点数
         	- 在内存在存储的时候会带上小数点。
          - 缺点：
            1. 现在的计算机都是64位的，按该方法，内存中存储的数的大小限制较大。如果两个差异特别大的数比如10的30次方和10的-30次方，是没有办法一块进行运算的。
            2. 计算的过程中首先要寻找小数点，对齐进行计算，过程比较复杂。
       - 浮点数
         	- 使用类似于科学计数法的方法，以0.xxx乘以10的n次幂的方法。其中小数点后一位 **必须不为0，小数点前面为0**，其中 **0.xxx表示尾数**，而 **10表示阶基**，最后 **n表示阶级**。该数的表现方式大大提高计算机一个字节可以存储的数的大小。

    - #### 按数的性质分(统称机器数)

       - 无符号数
         	- 所有位上的数都是有意义的数字。比如编码啊等，都是使用无符号数。
          - 运算：
            1. 加法
            2. 减法
            3. 乘法
            4. 除法
          
       - 有符号数
         	
         	- 最高位是符号位。表示数字的正负。比如1或者-1就是使用有符号数。
          
          - 有符号数的表示
       
             - 对于一个正数来说，其原码等于反码等于补码，即 X > 0; X原码 = X反码 = X补码
       
             - 对于一个负数来说，其反码等于原码除符号位取反，补码等于其反码加1；
       
             即  X < 0； X反码 = X原码取反(符号位置不取)
       
             ​				   X补码 = X反码 + 1；
       
             比如: X = 1 111 0000; 其反码是 1 000 1111； 其补码是 1 001 0000；
       
             - 原码
               	    - 原码就是给的数字本身，符号位，正数用0表示，负数用1表示。
       
             - 反码
               	    - 原码(负数)的符号位的数字不变，其余位数取反。 **原码** 和 **反码** 的缺点是基准不唯一，也就是0的表示由两种。同时减肥运算相较于加法运算更加麻烦。
       
             - 补码
               	    - 原码(负数)的反码加1。比如 +0 的原码是 0000 0000， -0的原码是 1000 0000，而它们的补码都是 0000 0000。 这样不但基数统一了，同时可以把减法运算变为加法运算。
       
          - 在计算机中的一个特殊的数字  **1 000 0000**
       
            	    - 他如果是无符号数，则表示为 2 的 7 次方， 即为 128；
             - 如果是有符号数字
               	    - 其原码表示为： -0
               	    - 其反码表示为:   -127
               	    - 其补码表示为:   -128 (这个是规定，因为补码把 +0 和 -0 统一了，所以多了一个位置， 人为的定义其为 -128 )
       
    - #### 计算机的局限性
    
       计算机可以表示的数的范围称为 **表数**；受硬件的影响的关系，不管是以前的8位计算机还是现在的64位计算机，对于数字的表示都是有范围的。如果超出了这个表示的范围，则称为 **溢出**。
    
       - 对于 **溢出** 的判断方法
         - 无符号数：最高位是否进位
           - 比如: 1111 1111 + 0000 0001 = 1 0000 0000 最高位进位，溢出
         - 有符号数：最高位和次高位是否同时有进位，或者同时没有进位。(只指加减)
           - 比如：0111 1111 + 0000 0001 = 1000 0000  次高位向最高位 进1，而最高位没有进位， 溢出。
       - 符号二进制和十进制的转化
         
         - 有符号数的二进制转化，需要求出真值都再进行转换。如果改数是正值，则原码反码补码皆是真值；如果是负数，需要将反码以及补码转化成原码，在进行转化。
         
           
    
- ## 基本逻辑运算与逻辑门

    - #### 逻辑运算的概念

        逻辑运算就是指对一个或者多个 **陈述句** 的命题进行判断其是否正确的过程。比如

        1. **今天我吃早餐** 为真命题， 

        2. **今天我吃早餐了，早餐吃的是馒头**， 这个命题是两个简单命题构成的复杂命题，判断其是否正确需要两个简单命题同时成立。但是结果只可能是真或者假

    

    - #### 使用逻辑运算的原因

      之所以在计算机中使用逻辑运算，是因为逻辑运算的结果只有只有两个状态，真或者假。其可以简单的对应生活中很多物理上的东西。比如开关的开和关，电压的高电平和低电平。数学上的 0 和 1。

    

    - #### 复杂命题的关系

        如上述第二个命题，多个简单命题可以构成复杂命题，但对于各个命题或者命题与自身之间的关系有三种表示。

        1. 非，对于已经得到的结果取反。比如上述 *例1* 取反即为假。使用符号 **1** 表示。其的状态和开关取反状态一致。
        2. 或，两个命题只要有一个成立即可。比如 **他是美国人或者他是中国人。** 多个命题称为 **或门**，使用符号 **>=1** b表示。其可以想象成并联电路，只要一个接通，就会有电。**因为只要有一个状态是真，其余的命题的结果就对总的结果产生不了影响，所以或门也是短路性质的**
        3. 并。 两个命题需要全部成立。如 *例2*。多个命题称为 **与门** ，使用符号 **&** 表示。其可以想象成串联电路。一个断电，全部没电。**因为只要有一个状态是假，其余的命题的结果就对总的结果产生不了影响，所以与门也是短路性质的**
        
    - #### 复杂逻辑运算
    
        复杂逻辑运算就像在数学运算的复杂运算一样，都是有简单的加减符号(与，或，非逻辑)构成的。用的很频繁的逻辑运算有：
    
        1. 与非门
    
           与非门就是对输入的值进行与操作，最后取反。
    
        2. 或非门
    
           或非门就是对输入的值进行或操作，最后取反。
    
        3. 异或门
    
           异或门表示的状态就是 **相同取0，不同取1**，是有符号 **⊕** 表示。也可以把它记为 **不进位相加**。比如
    
           A = 1011 0111 
    
           B = 0100 1001
    
           A ⊕ B = 1111 1110，A，B最后两个1相加等于2，应该进位，但是忽略进位，如此如果没有进位，直接按正常的运法法则计算即可。
    
        4. 同或门
    
           异或门的结果取反。

- ## 章节小结

  考虑下述问题是否清楚的知道。

  1. 微处理器，微型计算机，微型计算机系统三者有什么区别
  2. 计算机为什么要采用二进制，除了二进制还有什么其他的计算制
  3. 什么是有符号数，什么是无符号数
  4. 为什么要引入补码
  5. 冯诺伊曼计算机具有什么结构特点和基本工作原理
  6. 利用冯诺伊曼计算机执行一条指令的过程
  7. 什么是逻辑，真值表的含义
  8. 程序计数器PC的作用
  9. 不同计数制之间如何转换
  10. 原码，反码，补码之间的关系
  11. 二进制的运算
  12. 如何判断运算结果是否溢出
  13. 基本逻辑门电路的符号及输入与输出的关系
  14. 内存的组织模式
  15. **练习**：补码数 **A8H** 对应的十进制数是多少(注意：对于一个正数来说，原码=反码=补码；而对于负数则不是)；



- ## 8088/8086CPU

  - #### 为什么是8088/8086，它们的区别

    **8086芯片** 是第三代芯片，他的总线宽度为16位的，无论数对外或者对内，之前的芯片处理数据的能力是8位的。同时在8088/8086时代，该芯片也具备了并行流水的雏形，中断技术等等。更重要的是，如今的芯片和 **8086** 在重要的部分运行原理是一样的，都是使用冯诺伊曼体系。

    而 **8088与8086** 基本一致，只是对外，**8088** 为了兼容以前的软件等，采用的是8位总线。由于采用的是8位的总线，所以在引脚的一些地方是不同的。除此之外，**8088** 对内也是采用16位的总线，同时 **8088和8086** 使用的指令集是完全一致的。

  - #### 8088/8086相对于第二代芯片的特点

    - 采用了并行流水技术

      通过采用指令预取队列来完成，属于cpu内部结构的变化

    - 实现内存分段管理

      前面提及，内存是直接和cpu进行交互的，内存也被划分成一个一个具有相同存储字长的小格子。这些小格子具有固定的地址，cpu通过拿到某个小格子的地址，去找到这个小格子，获取里面的信息。

      而对于16位的处理器，其最多能表示2的16次方的地址也就是 64 k的地址，如果以这个标准，内存的容量就太小了。所以需要采取内存分段管理来达到内存地址由16位可以表达 1M ( 也就是 2 的 20 次方 )的内存。

      具体方法就是，将内存设置位4个段，并且设置内存寄存器。也就是实地址模式下的寻址。

    - 支持协处理器

      协处理器在今天已经看不见了，因为它已经集成到cpu里面去了。

      协处理器主要是用于浮点数的计算。因为以前都是定点计算，并不支持浮点运算，而定点计算的效率会低于浮点计算。

  - #### 8088/8086的工作模式

    因为支持协处理器，所以 8088/8086 支持两种工作模式： 最大工作模式，最小工作模式。

    - 最小工作模式
  
      只有主cpu在工作。由于控制信息都由主cpu完成，只有一个cpu工作，所以称为最小工作模式。其运行示意图如下：
  
      ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190617_1.png)
  
      因为8088对内存进行一次操作，首先是要知道要操作的内存信息的地址，其次是发出控制指令，在然后就是读取信息。所以8088发出内存信息地址，这时候，由于总线都是共用的，但是内存信息的地址不可以被覆盖，所以有一个ALE指令，将内存地址锁起来。避免其他信息通过产生的电平，将地址信息覆盖。
  
    - 最大工作模式
  
      由主cpu和协cpu一同工作。这个时候，所有的控制信息就不是都有主cpu发出，总线控制器会将一些由总cpu发出的指令分解然后传递出去。也就是总线cpu也担任了一部分产生控制指令的责任。
  
      以下是最大工作模式的工作流程:
  
      ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190617_2.png)
  
      对比于最小工作模式，多了总线控制器和数据收发的交互。
  
    - 判断在那个工作模式
  
      由 MN/MX 表示工作模式，处于哪个工作模式就在工作模式下电平就是个高电平.
      
      
    
  - #### 8088的主要引线及内部结构
  
    之前讲过，cpu完成一次指令的访问需要经过几个步骤
  
    1. 得到由 pc 所指的地址(地址可以在内存中，也可以在I/O接口中)
    2. 发出指令访问该内存地址
    3. 发出指令传输内存地址里面的数据(根据数据类型的不同做处理，如果数据是还是指令，则送去做指令译码等)
  
    由此可以知道，在完成这个过程需要分别对应下述三种信号
  
    1. 地址信号
    2. 控制信号
    3. 数据信号
  
    而8088在内部，总线的宽度为20，也就是有20根并行的总线，由此才能产生1M个不同地址码，管理1M的地址。但是对外8088只有8位宽度，所以遇到要传送16位的数据的时候，需要传送两次。对于20跟总线有以下三种分类：
  
    1. AD0 ～ AD7 表示数据通道(data)，用于传输低8位数据的。但是传输低8位地址信号也是使用它。它们属于分时复用。也就是错开时间使用。所以有上一章所提及的ALE信号来锁住地址信息，避免被数据信号冲掉。
    2. A8 ～ A15 8088处理器专有的地址信号
    3. A16 ～ A19 高4位的地址信号，和状态信号分时复用。<font color="red">这里所说的状态信号是不是就是控制信号呢？？？？</font>
  
    
  
    - 主要的控制信号
      - `#WR`
      - `#RD`
      - `IO/#M`
      - `#DEN`
      - `DT/#R`
      - `ALE`
      - `RESET`
    - READY信号
    - 中断请求和响应信号
      - 中断的意思是
    - 总线保持信号
      - 总线保持是为了
    
    
    
    - #### 8088内部结构
    
      - 8088内部结构分为 **执行单元(EU)**  和 **总线接口单元(BIU)**，如下图(这是示意图，不是原理图)
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190620_1.png)
    
      - 执行单元(EU)
    
        可以看见执行单元主要有4个部分组成
    
        1. 通用寄存器：暂存计算结果
        2. 运算器(ALU,算术逻辑单元)：执行指令
        3. FLAGS，标志寄存器：记录运算器在运算过程中的状态信息(比如有没有进位等)
        4. EU部分控制电路：指令译码
    
      - 总线接口单元(BIU)
    
        用于访问内存或者接口的部件。可以看见主要有以下部分
    
        1. 地址加法器：经过地址加法器从段寄存器中读入地址，在输出生成后的地址
    
        2. 指令队列：使得总线可以在 *EU* 工作的时候预取指令，达到并行工作(并行工作就是指: EU和BIU同时工作)的可能。
    
           对于预取队列，理想的情况是，第一次 EU传递给要取数据的地址， BIU取得数据，放入预取队列中，因为是第一个，所以队列为空，数据直接传递给EU进行指令译码。在EU指令译码，执行指令等过程中，BIU继续去取下一个指令放在预取队列中，EU上一个指令工作结束，马上可以从预取队列中获得下一个指令继续进行工作，从而实现不断流的并行工作。
    
           然而，这只是理想的情况。事实上，可以导致断流的因素有很多，比如
    
           1. 指令取过来，如果该指令需要数据，但数据没有取过来，所以 EU还需等待 BIU把需要的数据取来
           2. 如果取过来的指令是转移类指令，跳转到另外一个指令，则预取的指令依然不能用，需要去取跳转到的指令
    
      - 8088的进步
    
        总的来说：8088提高了运算的速率(有可能并行工作EU和BIU)，降低对存储器运行速度的要求(因为预取队列)
        
        
      
    - #### 8088内部寄存器
    
      1. 通用寄存器(8个)：**只要是通用寄存器就可以用来存放中间运算结果**
    
         - **数据寄存器** 有 4 个，由于8088是内部16位总线，所以处理数据可以达到16位。为了提高数据寄存器的灵活性，这 4 个寄存器分别是由 8 个8位的寄存器组成。比如 AX 由 AH 和 AL 组成； AH 和 AL是两个相互独立的寄存器，它们可以分开单独使用。但是当作为一个寄存器使用的时候，AH代表高 8 位的数据， AL 代表低 8 位的数据
    
           1. **AX** = AH + AL
    
              由于AX的效率相较于其他寄存器来说较高，所以一般用来在 I/O 操作的时候，和接口对接，传送消息。中间运算结果也多半会放在该寄存器中。AX里面的数据没有二义性，只可能是运算结果。
    
           2. **BX** = BH + BL
    
              在寻址的中用于存放基地址
    
           3. **CX** = CH + CL
    
              在循坏操作或者串操作的时候，用于存放计数值，比如说循环操作的时候，循环到第几次的次数就存放在这里面
    
           4. **DX** = DH + DL
    
              在间接寻址的 I/O 指令中存放 I/O 端口地址。在处理32位运算数时， 用于存放高 16位数。
    
         - **地址指针寄存器**
    
           1. **SP** 堆栈指针寄存器，其内容为栈顶的偏移地址，也是在堆栈操作的时候，其存放的地址总是指向栈顶，只要有堆栈操作，其就是专用寄存器 
           2. **BP** 基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址，在堆栈操作中，其可以指向栈中的任意位置
    
           **BX 和 BP 的区别在于 BX是活跃在数据段中；而 BP是活跃在堆栈段**
    
         - **变址寄存器** 变址寄存器在指令中常用于存放数据在内存中的地址
           1. **SI** 源变址寄存器
           2. **DI** 目标变址寄存器
    
      2. 段寄存器(4个) 用于存放逻辑段的段基地址
      
         - **CS** 代码寄存器
         - **DS** 数据寄存器
         - **ES** 附加段寄存器
         - **SS** 堆栈段寄存器
      3. 控制寄存器(2个)
         - **IP** 指令指针，在BI要取指令，会去看IP所指的位置，IP指向哪里就去哪里取？完全取决于程序计数器(IP)的指向的位置。所以 IP 称为指令指针，instruct pointer。
         - **FLAGS** 标志寄存器，用来存储运算结果的特征，比如有没有溢出等等。 只有9位有意义，其他7位是空闲位。
           - 状态标志位(6位):
             - **CF(carry flag)** 进位标志位，最高位有进位或者借位 1，表示无符号数计算溢出
             - **SF(sign flag)** 符号标志位， 运算结果最高位是 1， 为1；
             - **AF(Auxiliary carry flag)** 辅助进位标志位，在加减操作时，若bit3向bit4有进位或者借位，为1；
             - **PF(parity flag)** 奇偶标志位，运算结果的低8位中， 1的个数为偶数时，为1
             - **OF(overflow flag)** 溢出标志位，有溢出则为 1，表示有符号数计算溢出
             - **ZF(zero flag)** 零标志位， 运算结果为0的时候，为 1
           - 控制标志位(3位)
             - **IF(Interrupt Enable Flag)** 中断允许标志位，当其为1时，使CPU可以响应可屏蔽中断请求
             - **TF(Trag Flag)** 陷进标志位，当其为1时，cpu单步执行
             - **DF(Direction Flag)** 方向标志位，在数据串操作时确定操作的方向
      
      
    
    - #### 实模型下的存储器寻址
    
      - 内存储器管理
    
        由于8088时一个16位的芯片，所以无论是他的总线宽度，并行处理数据的位数都是16位的。这意味着，它可能同时管理2的16次方也就是64k个地址。但是64k的个地址实在是太小了。所以，需要有一个办法来提神其管理的容量。
    
        借助大楼的思想，在一层的房间都是以1开头，二层的则是以2开头。可以在内存地址中，在16位的前面加上4位区域地址，就可以管理 1M 内存了。
    
        但是这个管理方法有缺点：
    
        1. 因为cpu是16位的，而如果要使用4位的区域地址，而需要在添加专门的4位的寄存器，总线等等。与原本的cpu的体系格格不入
        2. 这个办法会导致单位内存利用率低下，比如，在一块内存中，如果一块内存被占用了。但是实际上它用不到那么大的内存，这会导致内存的浪费。
        
      - 内存单元的编址
      
        也是把内存分为一个一个的区域，为每个区域编上编号，再在每个区域中定义一块内存在该区域中所占据的位置。每个区域的编号就是段基地址，而在该区域中的位置，采用偏移地址的方式。也就是指定地址距离第一个地址的距离，称为段内地址。
      
        - 段基地址
      
          指存储单元在整个内存空间中处于哪个区域。8088只有4种区域，也就是4种段基地址，分别存在段寄存器中，每个逻辑段中存储单元的数量最多不超过 **64k**个：
      
          1. 代码段 存放指令代码
          2. 数据段 存放操作的数据
          3. 附加段 存放操作的数据
          4. 堆栈段 存放暂时不用但需要保存的数据
      
        - 段内地址
      
          指存储单元在段内的相对地址，也就是距离段内第一个存储单元的偏移量
      
        **无论是段基地址还是段内地址，都是16位的。**
      
        - 段首
      
          段首就是指在一个段中第一个存储单元，由于其相对于自己的偏移量是0，所以段首的段内地址就是0 。
      
        **所以得到的结论就是，一个存储单元的地址 = 该存储单元所在段的段首地址 + 偏移地址**
      
        由于段首地址的偏移量是 0；所以16位0，4位0，1位0都是0。 而对于管理 1M 个内存单元来说， 只需要20位即可。所以在 **内存分段的时候，每个段的段首，都是以节为边界来起始的，也就是说任何一个段的段首地址都要能够被16整除** 的前提下，可以将16位的 0 转写成4位的 0。
      
        - 物理地址
      
          独一无二的内存地址，也就是说，每个内存其实都是有一个独一无二的内存地址的。如果我们的技术可以做都内存中有 1M个内存单元，也就是说有 1M个客观存在真实内存地址。我们要怎么去使用 16位的cpu去管理这 1M的内存单元呢。
      
          基于上述的 **段基地址**， **段内地址**， **段首地址**，就可以由 16位的cpu去管理 20位的地址。
      
          所以物理地址 = 段首地址 + 段内地址(偏移地址)。
        
      - **总结一下**： 在8088中，所使用的内存芯片的大小是 1M，所以每个内存地址最少要用 20位( 2的20次方 )来表示。并且，每个内存单元都对应着 **唯一的，确定的，<font color="red">不变的</font>** *物理地址*。也就是说，在 8088中，如果一个内存地址是20位，那这个地址一定是某一个内存单元的 **<font color="yellow">物理地址</font>**。
      
        而物理地址又是由 **段基地址(16位)** + **段内地址(16位)** 所得。而 **段内地址** 指的是所使用的内存地址距离第一个内存单元( **段首地址**)的偏移量，所以 **段首地址** 就变成找到所使用内存单元的一个重要条件。但是 **段首地址** 也是存放在内存中的，它也有具体的物理地址，而他自己对于自己的偏移量是 **0**； 所以，段首地址就等于 **段基地址向左偏移16位**；由于 **16位的0，也是0，4位的0也是0；1位的0也是0**，而 8088的内存单元的物理地址是 20位的，所以在 **<font color="red">8088中，内存单元的物理地址是由20位组成，而所有20位的地址一定是内存单位的物理地址</font>**
        
        比如在8088中，一个段基地址是 2309H
        
        他的逻辑段首地址是 2309 : 0000 H
        
        他的物理段首地址是 23090H
        
      - 例子
      
        - 设某个数存放在数据段中，段基地址 DS = **250AH** ,数据所在单元的偏移地址是 **0204H** ，数据的物理地址是多少。
      
          **物理地址 = 段首地址 + 偏移地址**
      
          段基地址： 250A0 H (向左移动4位，由16进制表示就是一位，所以在后面加一个 0 )
      
          偏移地址： 0204H
      
          物理地址：250A0 + 0204 = 252A4H
      
        - 已知 **CS=1055H**, **DS=250AH**, **ES=2EF0H**,**SS=8FF0H**，画出各段在内存中的分布(默认每个段的大小是 64K)
      
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190702_1.png)
      
          
      
      - 由于逻辑地址的是由 **段基地址** 加上 **偏移地址** 组成，这两个地址都是逻辑上的，并且 **段基地址** 是存储在段寄存器中的，这意味着 **段基地址** 是可以变化的，这就使得一个段的位置可以在内存中路灵活的变换。同时，一个内存单元的的地址是由偏移量所决定的，这使得一个段可以和一个段相互交叉，一个内存地址可以分时被两个段所使用。
      
      - #### 逻辑段和逻辑地址
      
        - 内存的分段是逻辑分段，不是物理分段。各个逻辑段在地址上可以不相连，可以部分重合，也可以完成重合。
        - 每个内存单元一定具有 **<font color='red'>唯一的物理地址</font>**，但可以 **<font color="red">多个逻辑地址</font>**
      
      - #### 操作系统和逻辑段
      
        逻辑段之所以是采用 段基地址 + 偏移地址 来表示，这是由于操作系统的原因，我们写好的程序在不使用的时候是放在硬盘中的，在使用程序的时候，操作系统会把程序代码读入到内存中，插入内存的方式是见缝插针式的。所以想要表示出一个内存的地址，就要知道它是什么类型的代码，存放在哪个区域，距离该区域的段首地址的偏移量是多少。
      
        在电脑中，段基地址是由操作系统来控制的。
      
      - #### 堆栈段
      
        - 内存中一个特殊区域，用于存放暂时不用或需要保护的数据
        
        - 常用于响应中断或子程序调用
        
        - 指针
          - 栈顶 SP，SP (地址指针寄存器)指向栈顶的位置
          - 栈底 SS，SS是堆栈寄存器的段基地址
          
        - 例 SS = 1000H，SP= 0100H，求栈顶地址
        
          段首地址为 10000H， 栈顶偏移地址为 0100H， 栈顶地址为 10100H
        
        - 例 SS = 1000H，该段最后一个单元位 10200H。则栈底偏移地址为？
        
          段首地址为 10000 H， 最后一个单元为 10200H， 偏移地址为 10200 - 10000 = 0200 Hs
          
          
      
    - ### 8088系统总线
    
      - #### cpu时序
    
        cpu时序指的是cpu在工作过程中的各个引脚信号在时间的关系。以以下8088的工作时序图为例
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_1.png)
    
        - 在该图中，x轴表示时间，y轴表示各个引脚信号在不同时间的幅值(高低电平)。
        - CLK 表示时钟，就像在 人类社会的时钟一样，计算机在运行的过程中，也需要一个时钟，CLK就是这个时钟
        - A19/S6 - A16/S3 表示 A19 - A16 与 S6 - S3 所分时复用的总线。这里表示的状态是总的如(A19-A16)的状态，并不是单一的某个总线的状态。
        - A15 - A8， AD7 - AD0 同理
        - ALE 表示地址所存信号， 高电平的时候有效， 单有总线输出的是地址信号的时候， ALE为高电平， 表示有效， 将地址信号锁存
        - IOM 表示读取信号的位置是接口还是内存
        - RD表示读信息， 低电平有效，当为低电平的时候，可以进行读操作
        - DT/R 读取方法
        - DEN 片选信息， 有效才能才信息读取进来cpu
    
      - #### 总线周期
    
        cpu访问一次内存或者接口所需要的时间，包括四个阶段，T1,T2,T3,T4。如果在一个周期内有延时则在T3后 main添加TW阶段，可以添加多个TW。
    
        ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_2.png)
    
      - #### 总线分类
    
        - 按照传送信息的角度
          - 地址总线
          - 数据总线
          - 控制总线
        - 按照层次分类
          - cpu总线，cpu总线的标准并不统一，所以如果将cpu与接口相连，对于接口的制作不利，所以cpu总想必须要与系统总线相连
          - 系统总线，有统一的标准，现在主要有两种，PEI和PEIC总线。连接cpu和接口
          - 外部总线，连接cpu与外接设备如键盘等
    
      - #### 总线结构
    
        - 单总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_3.png)
    
          单总线的结构的缺点很明显：
    
          1. 接口设备和内存使用统一条总线，为了迁就接口设备，会导致总线上的速度不会太快，从而降低计算机运行效率
          2. 总线上挂着多个设备，导致争用问题很严重
    
        - 双总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_4.png)
    
          将内存和cpu的交互与接口和cpu的交互的总线分开，提高了计算机的运行效率。但是接口与内存的的交互就必须要通过cpu控制，也就是软件进行控制，这样速度同样不会太快。
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_5.png)
    
          在内存和接口也连接一条总线，是的接口和内存可以相互访问。
    
        - 多总线结构
    
          ![](/Users/mimee/Documents/my-git/学习笔记/12_计算机基础/微机原理/image/20190704_6.png)
    
      - ####总线功能
    
        - 传输数据
        - 仲裁功能
        - 出错处理
        - 数据驱动
    
      - #### 总线评价指标
    
        - 总线带宽 B/S
    
          单位时间里，总线所传送数据的能力
    
          总线带宽 = 总线宽度(如 8 位) * 工作效率( 传输数据的速度)
      
    
    
    
    - ## 指令系统概述与数据传送指令
    
      - ### 指令系统的基本概念
    
        - #### 指令及指令系统
    
          - 指令：指的是人对计算机发出的指令。
    
          - 指令系统：因为指令是人对计算机发出的，然而人和计算机是不可以直接沟通的，所以计算机可以识别的指令的集合就是该cpu的系统集合
    
          - 指令的兼容性：随着cpu的发展，cpu的指令会有所改变，但是后一代的cpu可以识别上一代的指令，这就是指令的兼容性。
    
          - 指令包含的信息以及格式
    
            - 包含的信息：分析指令的含义可以知道指令要包括： 从哪里来，去哪里，做什么三个部分
    
            - 格式： 操作码 [操作数] [操作数]
    
              这里的操作码就是该指令应该干什么，中括号表示操作数是可选填的。第一个操作数是目标操作数也就是去哪里，它可能代表一个含义也可能代表两个含义，一定代表的是地址，因为计算机每次操作完一个流程，必须要知道操作的结果放在哪里。它也可能同时表示目标地址和操作数。比如 add 5 3，5就表示地址和操作数。第二个操作数可能是数据也可能是地址码
    
            - 分类，无操作数指令和单操作数指令并不是真正的没有操作数，而是因为操作对象是默认的，所以隐藏起来了。
    
              - 无操作数指令
              - 单操作数指令
              - 双操作数追指令
              - 多操作数指令
        
            - 操作数的种类
        
              - 立即数 
        
                立即数就是一个常量，就是一个数字。可以直接被cpu使用。 **<font color='red'>由于立即数只是一个数，没有任何其他的含义，也就是不能表示地址，所以立即数不能作为目标操作数，因为目标操作数必须是一个地址</font>**
            
              - 寄存器地址
            
                在cpu中有专门存放运算中间结果的地方，称为寄存器比如(AX,BX …)；所以它表示一个地址。如果操作数是它，因为在cpu内，所以运算速度比较快。
            
              - 存储器地址
            
                如果操作数使用 `[]`中括号括起来的，就表示存储器地址，也就是操作数被放在了内存中。比如 `MOV AL [1210H]` 就表示把偏移地址为 1210H的单元里面的数字移动至 AL中。**<font color='red'>注意：一般我们都只会操纵存储单元的偏移地址，所以`[ ]`中，是偏移地址。</font>** 如果目标地址是一个16位的存储单元，则cpu会搬运 1210H以及 1211H 存储单元里面的内容。 **<font color='red'>也就是源目标数据的长度由目标操作数决定</font>**。
            
          - #### 寻址方式
        
            - 立即寻址
            
              说白了，就是操作数是立即数，只是以寻址的方式去分类。所以其的注意和立即数一样。
            
              立即寻址就是指操作的对象就是给出的操作数。比如 `MOV AX 1200H`；其中1200H就是一个操作数直接给出的。所以立即寻址一般是和代码一块放在代码段的。
            
              所以立即寻址不可以表示目标操作数。**<font color='red'>所有的寻址方式中，操作数的长度是8位还是16位是由另外一个操作数所决定的</font>**
            
            - 寄存器寻址
            
              指令存放在寄存器中。
            
              **数据通常是放在通用寄存器中的，偶尔会在段寄存器中，绝不会在控制寄存器中**
            
            - 存储器寻址
            
              数据存储在存储器中。需要注意三点
            
              1. 表现形式，由中括号 `[ ]` 包裹
              2. `[ ]`表示偏移地址，这个偏移地址不是真实的偏移地址，因为在编写程序的时候没有办法确定段基地址，只有在程序进行编译的时候，计算机会将计算出真实的偏移地址，由给出的偏移地址加上段基地址组成。
              3. 逻辑段的段基地址地址通过默认或者重设的方式给出
              4. 存储器操作数的字长并不确定。
            
              存储器寻址又包括
            
              1. 直接寻址： 指令中直接给出操作数的偏移地址 `MOV AX [1200H]`;
                 - 操作数位置与段重设：段地址默认是在数据段中的，但是允许段重设比如：MOV AX, ES: [1200H]；
              2. 间接寻址：**数据存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容**。也就是说，偏移地址存放在某一个寄存器中。`MOV AX [BX]`
                 - 间址寄存器：可以用来存放数据的间接地址，只有四个通用寄存器：**BX**, **BP**,**SI**,**DI**;
                 - 操作数的位置与段重设：
                   - 如果偏移地址存放在 **BX**, **SI**, **DI**; 则默认是在数据段中
                   - 如果偏移地址放在 **BP** 中，则默认在堆栈段中
                   - 同样可以通过段重设的方式重设数据存放位置(不包括将数据存放在代码段中)
              
            - 寄存器相对寻址
            
              操作数的偏移地址为寄存器的内容加上一个位移量： MOV AX, [BX+DATA], 也可以写作 MOV AX, DATA[BX], MOV AX [BX]DATA
            
            - 基址、变址寻址
            
              - 操作数的偏移地址： 一个基址寄存器( BX ：默认在数据段, BP ：默认在堆栈段 )的内容 + 一个变址寄存器( DI, SI )的内容；基址寄存器内存储的内容主要是段基地址，变址寄存器中存储的主要是偏移地址
            
              - 用途：**与相对寻址一样，主要是用于一维数组操作**
            
              - 例子: 下述地址表示偏移地址为 2200H，存储在数据段中。
            
                ```js
                MOV SI, 1100H
                MOV BX, SI
                MOV AX, [SI + BX]
                ```
            
            - 基址，变址，相对寻址
            
              - 操作数的偏移地址组成： 一个基址寄存器( BX ：默认在数据段, BP ：默认在堆栈段 )的内容 + 一个变址寄存器( DI, SI )的内容 + 位移量。
              - 用途：主要用于二维数组，表头，行地址，列地址
            
            - 隐含寻址
            
              - 指令中隐含一个或者两个操作数，也就说操作数是默认的。
              
            - 寻址练习
            
              - 设 DS = 6000H, ES = 2000H, SS = 1500H, SI = 00A0H, BX = 0800H, BP = 1200H, 字符常数 VAR 为 0050H。 说明以下各条指令源操作数的寻址方式及存储器操作数的物理地址。
                - `MOV AX, BX` 寄存器寻址, 寄存器操作数不存在物理地址，它只是一个符号而已。
                - `MOV DL, 80H` 立即寻址
                - `MOV AX, VAR[BX][SI]` 基址变址相对寻址，BX,BP存储段基地址，SI, DI存储着偏移地址。 所以偏移地址为。0800 + 00A0 + 0050 = 08F0; 由于有BX存在，所以默认存储在数据段中，所以段基地址为 DS 6000H, 段首地址为 60000H；则物理地址为 608F0 H；
                - `MOV AL 'b'` 立即寻址
                - `MOV DI, ES: [BX]` 段重设，存储器间接寻址。偏移地址 0800H, 段重设后段首地址为 20000H, 物理地址为 20800H 
                - `MOV DX, [BP]` 由于存储地址为 BP, 所以默认放在堆栈区，所以物理地址为 15000 + 1200 = 16200H
                - `MOV BX, 20H[BX] ` 存储器相对寻址,  地址存储在 BX 中，默认在数据段，所以偏移地址为 0800H + 2000H 即 2800H；物理地址为 60000H + 0820H = 60820H
                
                
            
          - ### 通用数据传送指令
          
            - 8086指令集
              - 数据传送
                - 通用数据传送指令(**不影响**标志位）
                  - `MOV dest, src` 双操作数
                    - 要求两个操作数必须等字长
                    - 要求两个操作数不允许同时为存储器操作数
                    - 两个操作数不允许同时为段寄存器( 也就是不允许将一个段寄存器的值赋予给另外一个段寄存器 )
                    - 源操作数是立即数的时候，目标操作数不能是段寄存器( 也就是说段寄存器不允许使用立即寻址的方式赋值 )
                    - IP 和 CS 不作为目标操作数，FLAGS一般也不作为操作数在指令中出现( IP是地址指针, CS是代码寄存器，一般不会作为操作数出现，一定不能作为目标操作数 )
                    - 例子
                      - `MOV AL, BX` 错误，操作数不等字长
                      - `MOV AX, [SI]05H` **正确**
                      - `MOV [BX][BP], BX` **错误**，BX，BP 是存放基址的寄存器， SI，DI存放变址的寄存器。从寻址方式上来说，没有将基址寄存器中的地址赋予给基址寄存器的方式。只有基址变址。 
                      - `MOVE DS, 1000H` **错误**，不可以使用立即寻址的方式给段寄存器( CS，DS，ES，SS)赋值。
                      - `MOV DX, 09H` **正确**
                      - `MOV [1200H], [SI]` 错误，两个操作数同时为存储器操作数
                - 输入输出指令(**不影响**标志位）
                - 地址传送指令(**不影响**标志位）
                - 标志传送指令(**影响**标志位）
              - 算术运算
              - 逻辑运算和移位
              - 串操作
              - 程序控制
              - 处理器控制
        




